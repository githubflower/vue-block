{"version":3,"sources":["util.js"],"names":["_dagre","_interopRequireDefault","require","_qblock","NAME_SPACE","SOUP","Util","isDefined","a","createEl","tagName","attrs","dom","document","createElementNS","_typeof","key","setAttribute","field","container","this","name","id","value","createFieldDom","comment","pinned","commentDom","textContent","createStateDefBlock","state","index","valueDom","createCommentDom","stateDom","appendChild","fieldDom","thread","nextDom","_this","outputAry","length","mutation","outputDom","forEach","outputItem","outputStateDom","createNextStatesDom","concat","lineId","line","lineAry","find","item","stateAry","stateId","endState","state2dom","error","createNextStatesDom2","nextStatesDom","parentDom","_this2","console","triggerEventStatement","triggerEventDom","d","desc","JSON","stringify","genBlockType","type","ret","el","x","y","saveStateBlockDataInDom","saveStateXY","saveLineData","startState","rootState","threadData","rootEl","log","stateType","createThreadDefDom","threadProcedureId","threadDefDom","procedureSelectBlockDom","fieldProcedureDom","statementDom","createThreadProcedureDom","statesDom","threadProcedureDom","genUid","soupLength","i","charAt","Math","random","join","children","ary","Array","prototype","slice","call","toNum","str","parseInt","replace","parentNode","parent","getAttribute","getStateXY","existStates","getLineDom","prevLineId","translatePX2Num","getPrevStateDom","prevStateDom","prevY","prevX","getEntityStateId","gap_x","state2blockly","threadAry","statePageData","blocklyXml","firstState","listsDom","mutationDom","stateDefBlock","procedureDefId","gap_y","outerHTML","blockly2state","xmlDom","parseFromString","STATE_BLOCK","by","inputAry","nodeHeight","findOutputLinesOfStateDom","outputLines","getDomChildren","child","newLine","lineDom","dom2State","getStartStateDomOfLine","getEndStateDomOfLine","push","stateObj","inputLines","j","existLineOfInputLines","statement","existLineOfLineAry","childNodes","nodeName","endStateDom","copyBlocklyXml2Clipboard","hiddenInput","createElement","width","body","height","focus","select","removeChild","iframeDom","getElementById","findInputLinesOfStateDom","workspaceToDom","Code","workspace","existStateInStateAry","Xml","resetAllStateData","extractStateAndLine","autoLayout","getVirtualHeight","virtualHeight","findFirstState","statementChildren","outputStates","lineObj","endStateOfLine","sum","prevState","xmlText","Blockly","doms","getElementsByClassName","testLayout","g","dagre","graphlib","Graph","align","edgesep","ranksep","label","QBlock","State","getStateWidth","getStateHeight","layout","node","nodeId","setStateXYbyNode","store","stateData","lineMap","refresh","rankdir","halfStateWidth","halfStateHeight"],"mappings":"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","file":"util.min.js","sourcesContent":["const NAME_SPACE = \"https://developers.google.com/blockly/xml\";\r\nconst SOUP = '!#$%()*+,-./:;=?@[]^_`{|}~ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\r\n\r\nimport dagre from 'dagre'\r\nimport QBlock from './qblock.js'\r\nvar Util = {\r\n    isDefined(a) {\r\n        return !((a === '') || (a === null) || (typeof a === 'undefined'));\r\n    },\r\n    createEl(tagName, attrs) {\r\n        var dom = document.createElementNS(NAME_SPACE, tagName);\r\n        if (typeof attrs === 'object') {\r\n            for (var key in attrs) {\r\n                dom.setAttribute(key, attrs[key]);\r\n            }\r\n        }\r\n        return dom;\r\n    },\r\n    createFieldDom(field) {\r\n        let container = this.createEl(\"field\");\r\n        container.setAttribute(\"name\", field.name);\r\n        if (field.id) {\r\n            container.setAttribute('id', field.id);\r\n        }\r\n        container.textContent = field.value;\r\n        return container;\r\n    },\r\n\r\n    /**\r\n     * 创建注释块Dom\r\n     * @param {*} comment \r\n     */\r\n    createCommentDom(comment) {\r\n        let commentDom = this.createEl('comment');\r\n        commentDom.setAttribute('pinned', comment.pinned || false);\r\n        commentDom.textContent = comment.value;\r\n        return commentDom;\r\n    },\r\n\r\n    /**\r\n     * 创建状态定义块Dom\r\n     * @param {*} state \r\n     * @param {*} index \r\n     */\r\n    createStateDefBlock(state, index) {\r\n        var valueDom = this.createEl('value');\r\n        valueDom.setAttribute('name', 'ADD' + index);\r\n\r\n        var stateDom = this.createEl('block');\r\n        stateDom.setAttribute('type', 'state_def');\r\n        stateDom.setAttribute('id', state.stateId);\r\n        var fieldDom = this.createFieldDom({\r\n            name: 'NAME',\r\n            value: state.name\r\n        });\r\n        stateDom.appendChild(fieldDom);\r\n\r\n        valueDom.appendChild(stateDom);\r\n        return valueDom;\r\n    },\r\n\r\n    /**\r\n     * 创建连线Dom以及其连接的状态块的Dom - 触发事件描述采用通用的if-else结构 controls_if \r\n     * ！此方法没有用到，代码暂时先放着\r\n     * @param {*} state \r\n     * @param {*} thread \r\n     */\r\n    createNextStatesDom(state, thread) {\r\n        let nextDom, outputDom;\r\n\r\n        if (state.outputAry.length) {\r\n            nextDom = this.createEl(\"next\");\r\n            outputDom = this.createEl(\"block\");\r\n            outputDom.setAttribute(\"type\", \"controls_if\");\r\n            if (state.outputAry.length > 1) {\r\n                let mutation = this.createEl(\"mutation\");\r\n                mutation.setAttribute(\"elseif\", state.outputAry.length - 1);\r\n                outputDom.appendChild(mutation);\r\n            }\r\n            state.outputAry.forEach((outputItem, index) => {\r\n                let outputStateDom;\r\n                outputStateDom = this.createEl(\"statement\");\r\n                outputStateDom.setAttribute(\"name\", `DO${index}`);\r\n                outputStateDom.setAttribute(\"id\", `${outputItem.lineId}`);\r\n                //outputAry里面只存放了lineId 所以我们需要做以下事情：\r\n                //1 根据lineId找到对应的line数据\r\n                //2 根据line里面的endState的stateId找到对应的state数据\r\n                let line = thread.lineAry.find((item) => {\r\n                    return item.lineId === outputItem.lineId;\r\n                });\r\n                if (line) {\r\n                    let state = thread.stateAry.find((item) => {\r\n                        return item.stateId === line.endState.stateId;\r\n                    });\r\n                    if (state) {\r\n                        outputStateDom.appendChild(Util.state2dom(state, thread));\r\n                    } else {\r\n                        console.error(\"data error -^- \");\r\n                    }\r\n                }\r\n                if (outputStateDom) {\r\n                    outputDom.appendChild(outputStateDom);\r\n                }\r\n            });\r\n            nextDom.appendChild(outputDom);\r\n        }\r\n        return nextDom;\r\n    },\r\n\r\n    /**\r\n     * 创建连线Dom以及其连接的状态块的Dom - 触发事件描述采用独立的结构 state_trigger_event\r\n     * @param {*} state \r\n     * @param {*} thread \r\n     */\r\n    createNextStatesDom2(state, thread) {\r\n        let triggerEventDom;\r\n        let nextStatesDom;\r\n        if (state.outputAry.length) {\r\n            /* if (state.outputAry.length > 1) {\r\n                let mutation = this.createEl(\"mutation\");\r\n                mutation.setAttribute(\"elseif\", state.outputAry.length - 1);\r\n                triggerEventDom.appendChild(mutation);\r\n            } */\r\n            let parentDom;\r\n\r\n            state.outputAry.forEach((outputItem, index) => {\r\n                let nextDom = this.createEl(\"next\");\r\n                if (!nextStatesDom) {\r\n                    nextStatesDom = nextDom;\r\n                }\r\n                triggerEventDom = this.createEl(\"block\");\r\n                triggerEventDom.setAttribute(\"type\", \"state_trigger_event\");\r\n                triggerEventDom.setAttribute(\"id\", outputItem.lineId);\r\n                // triggerEventDom.setAttribute(\"start_state\", JSON.stringify(state)); // TODO 按需简化存储的start_state数据\r\n\r\n                let triggerEventStatement;\r\n                triggerEventStatement = this.createEl(\"statement\");\r\n                triggerEventStatement.setAttribute(\"name\", `DO0`);\r\n                // triggerEventStatement.setAttribute(\"id\", `${outputItem.lineId}`);\r\n                //outputAry里面只存放了lineId 所以我们需要做以下事情：\r\n                //1 根据lineId找到对应的line数据\r\n                //2 根据line里面的endState的stateId找到对应的state数据\r\n                let line = thread.lineAry.find((item) => {\r\n                    return item.lineId === outputItem.lineId;\r\n                });\r\n                if (line) {\r\n                    triggerEventDom.setAttribute(\"d\", line.d);\r\n                    if (line.desc) {\r\n                        let commentDom = this.createCommentDom({\r\n                            value: line.desc\r\n                        });\r\n                        triggerEventDom.appendChild(commentDom);\r\n                    }\r\n                    let state = thread.stateAry.find((item) => {\r\n                        return item.stateId === line.endState.stateId;\r\n                    });\r\n                    if (state) {\r\n                        triggerEventDom.setAttribute(\"end_state\", JSON.stringify(state)); // TODO 按需简化存储的end_state数据\r\n                        triggerEventStatement.appendChild(Util.state2dom(state, thread));\r\n                    } else {\r\n                        console.error(\"data error -^- \");\r\n                    }\r\n                }\r\n                if (triggerEventStatement) {\r\n                    triggerEventDom.appendChild(triggerEventStatement);\r\n                }\r\n                nextDom.appendChild(triggerEventDom);\r\n                if (parentDom) {\r\n                    parentDom.appendChild(nextDom);\r\n                }\r\n                parentDom = triggerEventDom;\r\n\r\n            });\r\n        }\r\n        return nextStatesDom;\r\n    },\r\n\r\n    genBlockType(type) {\r\n        let ret = \"state_opr\";\r\n        if (type === \"loopDiv\") {\r\n            ret = \"controls_whileUntil\";\r\n        }\r\n        return ret;\r\n    },\r\n    /**\r\n     * 保存状态块的位置信息到Dom中\r\n     * @param {*} el 新建的和状态对应的Dom节点\r\n     * @param {*} state 当前操作的状态\r\n     */\r\n    saveStateXY(el, state) {\r\n        el.setAttribute(\"sx\", state.x);\r\n        el.setAttribute(\"sy\", state.y);\r\n    },\r\n    /**\r\n     * 保存状态块的数据到Dom中\r\n     * @param {*} el 新建的和状态对应的Dom节点\r\n     * @param {*} state 当前操作的状态\r\n     */\r\n    saveStateBlockDataInDom(el, state) {\r\n        switch (state.stateType) {\r\n            case 'stateDiv': //状态执行\r\n                this.saveStateXY(el, state);\r\n                break;\r\n            case 'state_trigger_event': //连线\r\n                this.saveLineData(el, state);\r\n            default:\r\n                break;\r\n        }\r\n    },\r\n    /**\r\n     * 保存连线数据到Dom\r\n     * @param {*} el 新建的和状态对应的Dom节点\r\n     * @param {*} state 当前操作的状态\r\n     */\r\n    saveLineData(el, line) {\r\n        el.setAttribute(\"d\", line.d);\r\n        el.setAttribute(\"start_state\", JSON.stringify(line.startState));\r\n        el.setAttribute(\"end_state\", JSON.stringify(line.startState));\r\n    },\r\n    /**\r\n     * 将一个状态块转为Dom节点\r\n     * @param {*} rootState \r\n     * @param {*} threadData \r\n     */\r\n    state2dom(rootState, threadData) {\r\n        let rootEl = this.createEl(\"block\");\r\n        console.log(\r\n            rootState.stateId +\r\n            \" --- \" +\r\n            rootState.name +\r\n            \" --- \" +\r\n            rootState.stateType\r\n        );\r\n        // rootEl.setAttribute(\"id\", rootState.stateId);\r\n        rootEl.setAttribute(\"type\", this.genBlockType(rootState.stateType));\r\n        this.saveStateBlockDataInDom(rootEl, rootState);\r\n\r\n\r\n        let fieldDom = this.createFieldDom({\r\n            id: rootState.stateId,\r\n            name: \"field_state\",\r\n            value: rootState.name,\r\n        });\r\n        rootEl.appendChild(fieldDom);\r\n\r\n        let nextStatesDom = this.createNextStatesDom2(rootState, threadData);\r\n        if (nextStatesDom) {\r\n            rootEl.appendChild(nextStatesDom);\r\n        }\r\n        return rootEl;\r\n    },\r\n    /**\r\n     * 创建线程定义块的Dom\r\n     * @param {*} thread \r\n     * @param {*} threadProcedureId 线程的函数id\r\n     */\r\n    createThreadDefDom(thread, threadProcedureId) {\r\n        /* <block type=\"thread_def\" id=\"ISJ:}kp8l):hy~wr5{x5\" x=\"-187\" y=\"-87\">\r\n            <field name=\"NAME\">thread</field>\r\n            <statement name=\"CALLBACK\">\r\n                <block type=\"procedure_select\" id=\"IK`|)2n6nVKsvFJ4VlXC\">\r\n                    <field name=\"field_procedure\" id=\"aewyJ+/)D`VHlrJ$BgFT\">thread_p</field>\r\n                </block>\r\n            </statement>\r\n        </block> */\r\n        // const procedureDefId = this.genUid();\r\n        let threadDefDom = this.createEl('block', {\r\n            type: \"thread_def\"\r\n        });\r\n        let fieldDom = this.createEl('field', {\r\n            name: 'NAME',\r\n            textContent: thread.name\r\n        });\r\n        fieldDom.textContent = thread.name;\r\n\r\n        let statementDom = this.createEl('statement', {\r\n            name: 'CALLBACK'\r\n        });\r\n        let procedureSelectBlockDom = this.createEl('block', {\r\n            type: 'procedure_select'\r\n        });\r\n        let fieldProcedureDom = this.createEl('field', {\r\n            name: 'field_procedure',\r\n            id: threadProcedureId,\r\n        });\r\n        fieldProcedureDom.textContent = thread.name + \"_function\";\r\n        procedureSelectBlockDom.appendChild(fieldProcedureDom);\r\n        statementDom.appendChild(procedureSelectBlockDom);\r\n        threadDefDom.appendChild(fieldDom);\r\n        threadDefDom.appendChild(statementDom);\r\n\r\n        return threadDefDom;\r\n    },\r\n    /**\r\n     * 创建线程函数定义块的Dom\r\n     * @param {*} thread \r\n     * @param {*} threadProcedureId \r\n     * @param {*} statesDom 所有连接的状态\r\n     */\r\n    createThreadProcedureDom(thread, threadProcedureId, statesDom) {\r\n        console.log('---thread.name---' + thread.name);\r\n        /* <block type=\"procedures_defnoreturn\" id=\"aewyJ+/)D`VHlrJ$BgFT\" x=\"463\" y=\"-113\">\r\n            <field name=\"NAME\">thread_p</field>\r\n            <comment pinned=\"false\" h=\"80\" w=\"160\">Describe this function...</comment>\r\n            <statement name=\"STACK\">\r\n            </statement>\r\n        </block> */\r\n        let threadProcedureDom = this.createEl('block', {\r\n            type: 'procedures_defnoreturn',\r\n            id: threadProcedureId\r\n        });\r\n        let fieldDom = this.createEl('field', {\r\n            name: 'NAME',\r\n\r\n        });\r\n        fieldDom.textContent = thread.name + \"_function\";\r\n        let statementDom = this.createEl('statement', {\r\n            name: 'STACK'\r\n        });\r\n        statementDom.appendChild(statesDom);\r\n        threadProcedureDom.appendChild(fieldDom);\r\n        threadProcedureDom.appendChild(statementDom);\r\n        return threadProcedureDom;\r\n    },\r\n    /**\r\n     * 获取唯一id，同google blockly产生唯一id的方法\r\n     */\r\n    genUid() {\r\n        var length = 20;\r\n        var soupLength = SOUP.length;\r\n        var id = [];\r\n        for (var i = 0; i < length; i++) {\r\n            id[i] = SOUP.charAt(Math.random() * soupLength);\r\n        }\r\n        return id.join('');\r\n    },\r\n    getDomChildren(dom) {\r\n        var ary = [];\r\n        if (dom.children) {\r\n            ary = Array.prototype.slice.call(dom.children);\r\n        }\r\n        return ary;\r\n    },\r\n    toNum(str) {\r\n        return parseInt(str, 10);\r\n    },\r\n    translatePX2Num(str) {\r\n        if (/px/.test(str)) {\r\n            str = str.replace(\"px\", \"\");\r\n        }\r\n        return +str;\r\n    },\r\n    getPrevStateDom(dom) {\r\n        var parent = dom.parentNode;\r\n        if (parent) {\r\n            if (parent.getAttribute('type') === 'state_opr') {\r\n                return parent;\r\n            } else {\r\n                parent = this.getPrevStateDom(parent);\r\n            }\r\n        }\r\n        return parent;\r\n    },\r\n    getStateXY(stateDom, existStates) {\r\n        /**\r\n         * 1.获取这个Dom节点的sx, sy值，如果存在就使用这个值，如果不存在，则获取上一个状态的sx, sy值，然后查看这个stateDom处于上一个状态的outputAry中的第几个元素，假设是第3个，则\r\n         * XY的值为：  x: targetDom.sx + gap_x(水平方向间隔)  y: targetDom.sx + index * gap_y\r\n         */\r\n        const gap_x = 150;\r\n        const gap_y = 100;\r\n        let x = this.toNum(stateDom.getAttribute('sx'));\r\n        let y = this.toNum(stateDom.getAttribute('sy'));\r\n\r\n        function getLineDom(dom) {\r\n            var parent = dom.parentNode;\r\n            if (parent) {\r\n                if (parent.getAttribute && parent.getAttribute('type') === 'state_trigger_event') {\r\n                    return parent;\r\n                } else {\r\n                    parent = getLineDom(parent);\r\n                }\r\n            }\r\n            return parent;\r\n        }\r\n\r\n        let prevLineId = getLineDom(stateDom) && getLineDom(stateDom).getAttribute('id');\r\n        // 正常拼接的情况下这个prevLineId是一定存在的\r\n        if (!x || x === 'undefined') { // x是未定义的则 y也是未定义的\r\n            let prevStateDom = Util.getPrevStateDom(stateDom);\r\n            if (!prevStateDom) {\r\n                return {\r\n                    x: 0,\r\n                    y: 0\r\n                }\r\n            }\r\n            let prevX = this.toNum(prevStateDom.getAttribute('sx'));\r\n            let prevY = this.toNum(prevStateDom.getAttribute('sy'));\r\n            if (!prevX || prevX === 'undefined') {\r\n                prevX = 0;\r\n                prevY = 0;\r\n            }\r\n            x = prevX + gap_x;\r\n            var index = 0;\r\n            var prevState = existStates.find(item => {\r\n                return item.stateId === Util.getEntityStateId(prevStateDom);\r\n            })\r\n\r\n            prevState.outputAry.forEach((item, i) => {\r\n                if (item.lineId === prevLineId) {\r\n                    index = i;\r\n                    return false; // return false 结束forEach\r\n                }\r\n            })\r\n            y = prevY + index * gap_y;\r\n        }\r\n        return {\r\n            x: x,\r\n            y: y\r\n        }\r\n    },\r\n    getEntityStateId(stateDom) {\r\n        return stateDom.children[0].getAttribute('id');\r\n    },\r\n    /**\r\n     * 将所有线程的数据（包括了状态和连线）转为Blockly可识别的xml数据\r\n     * @param {*} threadAry 线程数据\r\n     */\r\n    state2blockly(threadAry) {\r\n        /**\r\n         * 1.找到线程中有开始标记的根状态\r\n         * 2.遍历根状态的output，生成特殊的if-else if 结构，注意：默认不采用else\r\n         *\r\n         */\r\n        let statePageData = threadAry;\r\n\r\n        let blocklyXml = Util.createEl(\"xml\");\r\n        blocklyXml.setAttribute(\r\n            \"xmlns\",\r\n            \"https://developers.google.com/blockly/xml\"\r\n        );\r\n\r\n        statePageData.forEach((thread, index) => {\r\n            let firstState = thread.stateAry[0];\r\n            let listsDom = Util.createEl('block');\r\n            listsDom.setAttribute('type', 'lists_state');\r\n            listsDom.setAttribute('x', 300 + (700 * index));\r\n            listsDom.setAttribute('y', 150);\r\n\r\n            let mutationDom = Util.createEl('mutation');\r\n            mutationDom.setAttribute('items', thread.stateAry.length);\r\n            listsDom.appendChild(mutationDom);\r\n\r\n            thread.stateAry.forEach((state, i) => {\r\n                let stateDefBlock = Util.createStateDefBlock(state, i);\r\n                listsDom.appendChild(stateDefBlock);\r\n                // blocklyXml.appendChild(stateDefBlock);\r\n            })\r\n            var statesDom = Util.state2dom(firstState, thread);\r\n            const procedureDefId = Util.genUid();\r\n            let threadDefDom = Util.createThreadDefDom(thread, procedureDefId);\r\n            let threadProcedureDom = Util.createThreadProcedureDom(thread, procedureDefId, statesDom);\r\n            if (Util.isDefined(thread.x)) {\r\n                threadDefDom.setAttribute('x', thread.x);\r\n            } else {\r\n                threadDefDom.setAttribute('x', index * 700);\r\n            }\r\n            if (Util.isDefined(thread.y)) {\r\n                threadDefDom.setAttribute('y', thread.y);\r\n            } else {\r\n                threadDefDom.setAttribute('y', 10);\r\n            }\r\n            threadProcedureDom.setAttribute('x', index * 700);\r\n            threadProcedureDom.setAttribute('y', 200);\r\n            //这个添加的顺序很重要！！！\r\n            blocklyXml.appendChild(listsDom);\r\n            blocklyXml.appendChild(threadProcedureDom);\r\n            blocklyXml.appendChild(threadDefDom);\r\n        });\r\n\r\n        return blocklyXml.outerHTML;\r\n    },\r\n    /**\r\n     * 将Blockly数据转为状态图可识别的数据\r\n     */\r\n    blockly2state(xmlDom) {\r\n        if (typeof xmlDom === 'string') {\r\n            xmlDom = new DOMParser().parseFromString(xmlDom, 'text/xml');\r\n        }\r\n\r\n        const STATE_BLOCK = 'state_opr';\r\n        let stateAry = []; //所有的状态数据集合\r\n        let lineAry = []; //所有的连线数据集合\r\n        function extractStateAndLine(stateDom) {\r\n            /* <block type=\"state_opr\" id=\"0eRjWo`*LW!O%5)$3!bj\" sx=\"394\" sy=\"201\">\r\n                <field name=\"field_state\" id=\"state-1607658086399\">状态描述0</field>\r\n            </block> */\r\n            if (stateDom.tagName === 'block' && stateDom.getAttribute('type') === STATE_BLOCK) {\r\n                let stateObj = {\r\n                    stateId: Util.getEntityStateId(stateDom), //!!!这里的id不是block.state_opr的 id 哟，而是它下面的field.field_state的id\r\n                    stateType: stateDom.getAttribute('type') === STATE_BLOCK ? 'stateDiv' : 'loopDiv',\r\n                    bx: parseInt(stateDom.getAttribute('x'), 10), // blockly中与此对应的图形块的x\r\n                    by: parseInt(stateDom.getAttribute('y'), 10), // blockly中与此对应的图形块的y\r\n                    x: Util.getStateXY(stateDom, stateAry).x, //stateDom.getAttribute('sx'),\r\n                    y: Util.getStateXY(stateDom, stateAry).y,\r\n                    width: '76px',\r\n                    height: '40px',\r\n                    // virtualHeight: Util.getVirtualHeight(outputAry), //TODO 开始状态为这个stateDom的所有状态高度之和\r\n                    name: stateDom.children[0].textContent,\r\n                    inputAry: [],\r\n                    outputAry: [],\r\n                    children: [],\r\n                    nodeHeight: 0 // 如果该节点有2个分支，且分支是叶子节点，则这个节点的nodeHeight = 2; 总之，nodeHeight = 各分支nodeHeight之和 - 这个参数为自动布局所用\r\n                }\r\n\r\n\r\n\r\n                function dom2State(dom) {\r\n                    let stateId = dom.getAttribute('id');\r\n                    if (dom.getAttribute('type') === STATE_BLOCK) {\r\n                        stateId = Util.getEntityStateId(dom);\r\n                    }\r\n                    return {\r\n                        stateId: stateId,\r\n                        stateType: STATE_BLOCK\r\n                    };\r\n                }\r\n\r\n                function findOutputLinesOfStateDom(stateDom, outputLines) {\r\n                    // 如果stateDom中有next节点 且 next节点的children中有block.state_trigger_event 则将这个block.state_trigger_event push 到 outputLines\r\n                    // 然后将这个block.state_trigger_event作为新的stateDom，查找其包含的block.state_trigger_event 这样遍历查找所有的block.state_trigger_event就找到了outputLines\r\n                    let children = Util.getDomChildren(stateDom);\r\n                    children.forEach(child => {\r\n                        if (child.tagName === 'next') { //所有next节点的children都只有1个\r\n                            if (child.children && child.children[0] && child.children[0].getAttribute('type') === 'state_trigger_event') {\r\n                                let lineDom = child.children[0];\r\n                                let newLine = {\r\n                                    lineId: lineDom.getAttribute('id'),\r\n                                    d: lineDom.getAttribute('d'),\r\n                                    startState: dom2State(Util.getStartStateDomOfLine(lineDom)),\r\n                                    endState: dom2State(Util.getEndStateDomOfLine(lineDom)),\r\n                                };\r\n\r\n                                let existLineOfOutputLines = outputLines.find(item => {\r\n                                    return item.lineId === lineDom.getAttribute('id');\r\n                                })\r\n                                if (!existLineOfOutputLines) {\r\n                                    outputLines.push(newLine);\r\n                                }\r\n\r\n                                let existLineOfLineAry = lineAry.find(item => {\r\n                                    return item.lineId === lineDom.getAttribute('id')\r\n                                })\r\n                                if (!existLineOfLineAry) {\r\n                                    lineAry.push(newLine);\r\n                                }\r\n                                findOutputLinesOfStateDom(lineDom, outputLines);\r\n                            }\r\n                        }\r\n                    })\r\n                    return outputLines;\r\n                }\r\n\r\n                function findInputLinesOfStateDom(stateDom, inputLines) {\r\n                    //逐级往上寻找type === 'state_opr'的块即inputLines    //  block.state_trigger_event > statement > block.state_opr\r\n                    let lineDom = stateDom.parentNode && stateDom.parentNode.parentNode;\r\n                    if (lineDom && lineDom.getAttribute('type') === 'state_trigger_event') {\r\n                        let newLine = {\r\n                            lineId: lineDom.getAttribute('id'),\r\n                            d: lineDom.getAttribute('d'),\r\n                            startState: dom2State(Util.getPrevStateDom(lineDom)),\r\n                            endState: dom2State(Util.getEndStateDomOfLine(lineDom))\r\n                        };\r\n\r\n                        let existLineOfInputLines = inputLines.find(item => {\r\n                            return item.lineId === newLine.lineId;\r\n                        })\r\n                        if (!existLineOfInputLines) {\r\n                            inputLines.push(newLine);\r\n                        }\r\n\r\n                        let existLineOfLineAry = lineAry.find(item => {\r\n                            return item.lineId === newLine.lineId;\r\n                        })\r\n                        if (!existLineOfLineAry) {\r\n                            lineAry.push(newLine);\r\n                        }\r\n                    }\r\n                    return inputLines;\r\n                }\r\n\r\n                findOutputLinesOfStateDom(stateDom, stateObj.outputAry);\r\n                findInputLinesOfStateDom(stateDom, stateObj.inputAry);\r\n\r\n                let existStateInStateAry = stateAry.find(state => {\r\n                    return state.stateId === stateObj.stateId;\r\n                })\r\n                if (!existStateInStateAry) {\r\n                    stateAry.push(stateObj);\r\n                }\r\n            }\r\n            if (stateDom.children && stateDom.children.length) {\r\n                for (let j = 0; j < stateDom.children.length; j++) {\r\n                    let child = stateDom.children[j];\r\n                    extractStateAndLine(child);\r\n                }\r\n            }\r\n        }\r\n        extractStateAndLine(xmlDom);\r\n        return {\r\n            stateAry: stateAry,\r\n            lineAry: lineAry\r\n        }\r\n    },\r\n    getStartStateDomOfLine(lineDom) {\r\n        return this.getPrevStateDom(lineDom);\r\n    },\r\n    getEndStateDomOfLine(lineDom){\r\n        let children = Array.prototype.slice.call(lineDom.childNodes);\r\n        let statement = children.find(dom => {\r\n            return dom.nodeName === 'statement'\r\n        })\r\n        let statementChildren = Array.prototype.slice.call(statement.childNodes);\r\n        let endStateDom = statementChildren.find(dom => {\r\n            return dom.nodeName === 'block'\r\n        })\r\n        if (!endStateDom){\r\n            console.error('数据错误：触发事件连线没有连接正确的状态');\r\n        }\r\n        return endStateDom;\r\n    },\r\n    /**\r\n     * 将Blockly数据复制到剪切板 - 调试时用\r\n     * @param {*} blocklyXml \r\n     */\r\n    copyBlocklyXml2Clipboard(blocklyXml) {\r\n        // window.stateDataXml = blocklyXml.outerHTML;\r\n        let hiddenInput = document.createElement(\"input\");\r\n        hiddenInput.setAttribute(\"type\", \"text\");\r\n        hiddenInput.setAttribute(\"value\", blocklyXml);\r\n        hiddenInput.setAttribute(\"style\", \"height: 0; overflow: hidden;\");\r\n        document.body.appendChild(hiddenInput);\r\n        hiddenInput.focus();\r\n        hiddenInput.select();\r\n        document.execCommand(\"copy\");\r\n        document.body.removeChild(hiddenInput);\r\n    },\r\n    workspace2dom() {\r\n        var xmlText = '';\r\n        var iframeDom = document.getElementById('blocklyIframe');\r\n        if (iframeDom) {\r\n            var win = iframeDom.contentWindow;\r\n            var xmlDom = win.Blockly.Xml.workspaceToDom(win.Code.workspace);\r\n            xmlText = win.Blockly.Xml.domToPrettyText(xmlDom);\r\n\r\n        } else {\r\n            console.error('当前页面没有嵌入blockly');\r\n        }\r\n        return xmlText;\r\n    },\r\n    /**\r\n     * 在自动布局前重置所有状态的x,y坐标\r\n     */\r\n    resetAllStateData(thread) {\r\n        if (thread) {\r\n            thread.stateAry.forEach(state => {\r\n                state.x = 0;\r\n                state.y = 0;\r\n            })\r\n        }\r\n    },\r\n    autoLayout(thread) {\r\n        if (thread) {\r\n            let firstState = Util.findFirstState(thread.stateAry);\r\n            thread.stateAry.forEach(state => {\r\n                let prevState; //TODO 当前状态的前一个兄弟节点\r\n                state.virtualHeight = Util.getVirtualHeight(state);\r\n                state.y = prevState.y + prevState.virtualHeight;\r\n            })\r\n        }\r\n    },\r\n    /**\r\n     * 找到“开始状态”\r\n     */\r\n    findFirstState(stateAry) {\r\n        return stateAry[0]; //TODO 后续根据特定标记查找\r\n    },\r\n    getVirtualHeight(state) {\r\n        let outputStates = [];\r\n        state.outputAry.forEach(line => {\r\n            let lineObj = thread.lineAry.find(item => {\r\n                return item.lineId === line.lineId;\r\n            })\r\n            let endStateOfLine = thread.stateAry.find(item => {\r\n                return item.stateId === lineObj.endState.stateId;\r\n            })\r\n            outputStates.push(endStateOfLine);\r\n        })\r\n\r\n        let sum = 0;\r\n        outputStates.forEach(state => {\r\n            if (!state.virtualHeight) {\r\n                state.virtualHeight = Util.getVirtualHeight(state);\r\n                sum += state.virtualHeight;\r\n            }\r\n        })\r\n        return sum;\r\n    },\r\n    getAutoXY(state) {\r\n        //x,y是同时设置的，所以只需判断其中一个即可\r\n        if (state.y) {\r\n            return {\r\n                x: state.x,\r\n                y: state.y\r\n            }\r\n        } else {\r\n            state.y = prevState.y + prevState.virtualHeight;\r\n        }\r\n    },\r\n    getDomByStateId(stateId){\r\n        let doms = document.getElementsByClassName('state-wrap');\r\n        return Array.prototype.slice.call(doms).find(item => {\r\n            return item.getAttribute('stateid') === stateId;\r\n        })\r\n    },\r\n\r\n    testLayout(thread) {\r\n        var g = new dagre.graphlib.Graph({\r\n            //directed: true,\r\n            //compound: true,\r\n            multigraph: true,\r\n           \r\n        });\r\n        g.setGraph({\r\n            rankdir: 'LR',\r\n            align:'UL',\r\n            edgesep:0,\r\n            ranksep:70\r\n        });\r\n        g.setDefaultEdgeLabel(function() {\r\n            return {};\r\n        });\r\n\r\n        thread.stateAry.forEach(state => {\r\n            g.setNode(state.stateId, {\r\n                label: state.name,\r\n                // width: state.width || 76,\r\n                // height: state.height || 40\r\n                width: QBlock.State.getStateWidth(state),\r\n                height: QBlock.State.getStateHeight(state)\r\n            });\r\n\r\n            state.outputAry.forEach(line => {\r\n                let lineObj = thread.lineAry.find(item => {\r\n                    return item.lineId === line.lineId;\r\n                })\r\n                let endState = thread.stateAry.find(item => {\r\n                    return item.stateId === lineObj.endState.stateId;\r\n                })\r\n                // g.setEdge(state.stateId, endState.stateId, line.lineId, lineObj.desc); //这种设置方式会报错 可能是dagre对graphlib的封装接口未同步\r\n                g.setEdge(state.stateId, endState.stateId, {\r\n                    label: line.lineId\r\n                });\r\n            })\r\n        })\r\n\r\n        dagre.layout(g);//布局分析\r\n\r\n        g.nodes().forEach(function(nodeId) {\r\n            let node = g.node(nodeId);\r\n            let state = thread.stateAry.find(item => {\r\n                return item.stateId === nodeId;\r\n            });\r\n            if (state){\r\n                Util.setStateXYbyNode(state, node)//重设状态位置信息\r\n                if(state.inputAry && state.inputAry.length){\r\n                    state.inputAry.forEach(item => {\r\n                        store.stateData.lineMap[item.lineId].refresh();\r\n                    })\r\n                }\r\n            }\r\n            console.log(\"Node \" + nodeId + \": \" + JSON.stringify(g.node(nodeId)));\r\n        });\r\n\r\n       /*  thread.lineAry.forEach(item => {\r\n            item.forceRefresh = false;\r\n        }) */\r\n      \r\n        /* setTimeout(() => {\r\n            \r\n            g.edges().forEach(function(line) {\r\n                console.log(\"Edge \" + line.v + \" -> \" + line.w + \": \" + JSON.stringify(g.edge(line)));\r\n                let lineObj = thread.lineAry.find(item => {\r\n                    return item.lineId === g.edge(line).label;\r\n                });\r\n                lineObj.d = '';\r\n            });\r\n        }, 300); */\r\n\r\n    },\r\n    setStateXYbyNode(state, node){\r\n        let halfStateWidth = QBlock.State.getStateWidth(state) / 2\r\n        let halfStateHeight = QBlock.State.getStateHeight(state) / 2\r\n        state.x = node.x - halfStateWidth\r\n        state.y = node.y - halfStateHeight\r\n        return\r\n    }\r\n}\r\nexport default Util;"]}