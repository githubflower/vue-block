{"version":3,"sources":["util.js"],"names":["_dagre","_interopRequireDefault","require","_qblock","_graphCfg","NAME_SPACE","SOUP","RANKSEP","lineCfg","rankSep","Util","isDefined","a","createEl","tagName","attrs","dom","document","createElementNS","_typeof","key","setAttribute","field","container","this","name","id","textContent","value","createCommentDom","comment","createFieldDom","pinned","commentDom","createStateDefBlock","state","index","thread","valueDom","stateDom","appendChild","fieldDom","children","length","startChild","find","item","inputAry","state2dom","statementDom","childrenDom","createNextStatesDom","nextDom","outputDom","_this","outputAry","mutation","forEach","outputItem","outputStateDom","concat","lineId","lineAry","line","store","getStateImplement","endState","stateId","stateAry","createNextStatesDom2","console","nextStatesDom","_this2","triggerEventDom","indexOf","triggerEventStatement","saveLineData","desc","error","parentDom","genBlockType","type","ret","saveStateXY","el","x","y","saveStateWidthHeight","width","saveStateMode","saveStateBlockDataInDom","log","stateType","threadData","rootState","mode","rootEl","createThreadDefDom","threadProcedureId","threadDefDom","fieldProcedureDom","createThreadProcedureDom","statesDom","threadProcedureDom","procedureSelectBlockDom","i","charAt","Math","random","soupLength","join","getDomChildren","ary","Array","prototype","slice","call","toNum","str","parseInt","translatePX2Num","test","replace","getPrevStateDom","parent","getAttribute","getStateXY","getLineDom","prevLineId","prevStateDom","prevX","prevY","getEntityStateId","gap_x","state2blockly","statePageData","threadAry","blocklyXml","listsDom","mutationDom","stateDefBlock","firstState","procedureDefId","genUid","prevState","existStates","outerHTML","xmlDom","DOMParser","parseFromString","stateLogicDom","getProceduresDefDom","listStateDom","STATE_BLOCK","updateChildrenOfState","extractStateAndLine","stateObj","bx","by","nodeHeight","findOutputLinesOfStateDom","outputLines","child","lineDom","d","dom2State","getEndStateDomOfLine","push","startState","newLine","parentNode","existLineOfOutputLines","existLineOfLineAry","inputLines","findInputLinesOfStateDom","existLineOfInputLines","j","childNodes","subStatesDom","element","stateAry2","getStateById","result","height","getListStateDom","existStateInStateAry","getStartStateDomOfLine","statement","endStateDom","nodeName","copyBlocklyXml2Clipboard","hiddenInput","body","select","execCommand","removeChild","workspace2dom","iframeDom","getElementById","win","Blockly","Xml","workspaceToDom","Code","workspace","domToPrettyText","xmlText","resetAllStateData","autoLayout","findFirstState","virtualHeight","getVirtualHeight","outputStates","lineObj","endStateOfLine","sum","getAutoXY","getDomByStateId","doms","getElementsByClassName","genGraphByLayer","threadIndex","layer","dagre","graphlib","Graph","g","setGraph","label","QBlock","State","getStateWidth","getStateHeight","setEdge","setStateXYbyNode","node","halfStateHeight","halfStateWidth","setStateXYbyLayer","nodes","nodeId","getState","stateData","lineMap","refresh","ranksep","testLayout","stateInCurrentLayer","layout"],"mappings":"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","file":"util.min.js","sourcesContent":["const NAME_SPACE = \"https://developers.google.com/blockly/xml\";\r\nconst SOUP = '!#$%()*+,-./:;=?@[]^_`{|}~ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\r\n\r\nimport dagre from 'dagre'\r\nimport QBlock from './qblock.js'\r\nimport { lineCfg } from \"./graphCfg.js\";\r\nconst RANKSEP = lineCfg.rankSep\r\nvar Util = {\r\n    isDefined(a) {\r\n        return !((a === '') || (a === null) || (typeof a === 'undefined'));\r\n    },\r\n    createEl(tagName, attrs) {\r\n        var dom = document.createElementNS(NAME_SPACE, tagName);\r\n        if (typeof attrs === 'object') {\r\n            for (var key in attrs) {\r\n                dom.setAttribute(key, attrs[key]);\r\n            }\r\n        }\r\n        return dom;\r\n    },\r\n    createFieldDom(field) {\r\n        let container = this.createEl(\"field\");\r\n        container.setAttribute(\"name\", field.name);\r\n        if (field.id) {\r\n            container.setAttribute('id', field.id);\r\n        }\r\n        container.textContent = field.value;\r\n        return container;\r\n    },\r\n\r\n    /**\r\n     * 创建注释块Dom\r\n     * @param {*} comment \r\n     */\r\n    createCommentDom(comment) {\r\n        let commentDom = this.createEl('comment');\r\n        commentDom.setAttribute('pinned', comment.pinned || false);\r\n        commentDom.textContent = comment.value;\r\n        return commentDom;\r\n    },\r\n\r\n    /**\r\n     * 创建状态定义块Dom\r\n     * @param {*} state \r\n     * @param {Number} index \r\n     * @param {*} thread \r\n     */\r\n    createStateDefBlock(state, index, thread) {\r\n        var valueDom = this.createEl('value');\r\n        valueDom.setAttribute('name', 'ADD' + index);\r\n\r\n        var stateDom = this.createEl('block');\r\n        stateDom.setAttribute('type', 'state_def');\r\n        stateDom.setAttribute('id', state.stateId);\r\n        var fieldDom = this.createFieldDom({\r\n            name: 'NAME',\r\n            value: state.name\r\n        });\r\n        stateDom.appendChild(fieldDom);\r\n\r\n        //如果children不为空则说明是嵌套状态，此时需要将子状态逻辑放到“状态定义块”内部\r\n        if (state.children && state.children.length) {\r\n            //找到第一个子状态（inputAry为空）\r\n            var startChild = state.children.find(item => {\r\n                return (!item.inputAry || item.inputAry.length === 0);\r\n            })\r\n            var childrenDom = Util.state2dom(startChild, thread);\r\n            var statementDom = this.createEl(\"statement\");\r\n            statementDom.setAttribute(\"name\", 'STACK');\r\n            statementDom.appendChild(childrenDom);\r\n            stateDom.appendChild(statementDom);\r\n\r\n            // valueDom.appendChild(childrenDom);\r\n        }\r\n\r\n        valueDom.appendChild(stateDom);\r\n\r\n        return valueDom;\r\n    },\r\n\r\n    /**\r\n     * 创建连线Dom以及其连接的状态块的Dom - 触发事件描述采用通用的if-else结构 controls_if \r\n     * ！此方法没有用到，代码暂时先放着\r\n     * @param {*} state \r\n     * @param {*} thread \r\n     */\r\n    createNextStatesDom(state, thread) {\r\n        let nextDom, outputDom;\r\n\r\n        if (state.outputAry.length) {\r\n            nextDom = this.createEl(\"next\");\r\n            outputDom = this.createEl(\"block\");\r\n            outputDom.setAttribute(\"type\", \"controls_if\");\r\n            if (state.outputAry.length > 1) {\r\n                let mutation = this.createEl(\"mutation\");\r\n                mutation.setAttribute(\"elseif\", state.outputAry.length - 1);\r\n                outputDom.appendChild(mutation);\r\n            }\r\n            state.outputAry.forEach((outputItem, index) => {\r\n                let outputStateDom;\r\n                outputStateDom = this.createEl(\"statement\");\r\n                outputStateDom.setAttribute(\"name\", `DO${index}`);\r\n                outputStateDom.setAttribute(\"id\", `${outputItem.lineId}`);\r\n                //outputAry里面只存放了lineId 所以我们需要做以下事情：\r\n                //1 根据lineId找到对应的line数据\r\n                //2 根据line里面的endState的stateId找到对应的state数据\r\n                let line = thread.lineAry.find((item) => {\r\n                    return item.lineId === outputItem.lineId;\r\n                });\r\n                if (line) {\r\n                    /* let state = thread.stateAry.find((item) => {\r\n                        return item.stateId === line.endState.stateId;\r\n                    }); */\r\n                    let state = store.getStateImplement(line.endState.stateId, thread.stateAry);\r\n                    if (state) {\r\n                        outputStateDom.appendChild(Util.state2dom(state, thread));\r\n                    } else {\r\n                        console.error(\"data error -^- \");\r\n                    }\r\n                }\r\n                if (outputStateDom) {\r\n                    outputDom.appendChild(outputStateDom);\r\n                }\r\n            });\r\n            nextDom.appendChild(outputDom);\r\n        }\r\n        return nextDom;\r\n    },\r\n\r\n    /**\r\n     * 创建连线Dom以及其连接的状态块的Dom - 触发事件描述采用独立的结构 state_trigger_event\r\n     * @param {*} state \r\n     * @param {*} thread \r\n     */\r\n    createNextStatesDom2(state, thread) {\r\n        let triggerEventDom;\r\n        let nextStatesDom;\r\n        if (state.outputAry.length) {\r\n            /* if (state.outputAry.length > 1) {\r\n                let mutation = this.createEl(\"mutation\");\r\n                mutation.setAttribute(\"elseif\", state.outputAry.length - 1);\r\n                triggerEventDom.appendChild(mutation);\r\n            } */\r\n            let parentDom;\r\n\r\n            state.outputAry.forEach((outputItem, index) => {\r\n                let nextDom = this.createEl(\"next\");\r\n                if (!nextStatesDom) {\r\n                    nextStatesDom = nextDom;\r\n                }\r\n                triggerEventDom = this.createEl(\"block\");\r\n                triggerEventDom.setAttribute(\"type\", \"state_trigger_event\");\r\n                triggerEventDom.setAttribute(\"id\", outputItem.lineId);\r\n                if (outputItem.lineId.indexOf('line') !== 0){\r\n                    debugger;\r\n                }\r\n                // triggerEventDom.setAttribute(\"start_state\", JSON.stringify(state)); // TODO 按需简化存储的start_state数据\r\n\r\n                let triggerEventStatement;\r\n                triggerEventStatement = this.createEl(\"statement\");\r\n                triggerEventStatement.setAttribute(\"name\", `DO0`);\r\n                // triggerEventStatement.setAttribute(\"id\", `${outputItem.lineId}`);\r\n                //outputAry里面只存放了lineId 所以我们需要做以下事情：\r\n                //1 根据lineId找到对应的line数据\r\n                //2 根据line里面的endState的stateId找到对应的state数据\r\n                let line = thread.lineAry.find((item) => {\r\n                    return item.lineId === outputItem.lineId;\r\n                });\r\n                if (line) {\r\n                    Util.saveLineData(triggerEventDom, line);\r\n                    if (line.desc) {\r\n                        let commentDom = this.createCommentDom({\r\n                            value: line.desc\r\n                        });\r\n                        triggerEventDom.appendChild(commentDom);\r\n                    }\r\n                    let state = store.getStateImplement(line.endState.stateId, thread.stateAry);\r\n                    if (state) {\r\n                        // triggerEventDom.setAttribute(\"end_state\", JSON.stringify(state)); // TODO 按需简化存储的end_state数据\r\n                        triggerEventStatement.appendChild(Util.state2dom(state, thread));\r\n                    } else {\r\n                        console.error(\"data error -^- \");\r\n                    }\r\n                }\r\n                if (triggerEventStatement) {\r\n                    triggerEventDom.appendChild(triggerEventStatement);\r\n                }\r\n                nextDom.appendChild(triggerEventDom);\r\n                if (parentDom) {\r\n                    parentDom.appendChild(nextDom);\r\n                }\r\n                parentDom = triggerEventDom;\r\n\r\n            });\r\n        }\r\n        return nextStatesDom;\r\n    },\r\n\r\n    genBlockType(type) {\r\n        let ret = \"state_opr\";\r\n        if (type === \"loopDiv\") {\r\n            ret = \"controls_whileUntil\";\r\n        }\r\n        return ret;\r\n    },\r\n    /**\r\n     * 保存状态块的位置信息到Dom中\r\n     * @param {*} el 新建的和状态对应的Dom节点\r\n     * @param {*} state 当前操作的状态\r\n     */\r\n    saveStateXY(el, state) {\r\n        el.setAttribute(\"sx\", state.x);\r\n        el.setAttribute(\"sy\", state.y);\r\n    },\r\n    saveStateWidthHeight(el, state) {\r\n        el.setAttribute(\"s_width\", state.width);\r\n        el.setAttribute(\"s_height\", state.height);\r\n    },\r\n    saveStateMode(el, state) {\r\n        el.setAttribute(\"mode\", state.mode);\r\n    },\r\n    /**\r\n     * 保存状态块的数据到Dom中\r\n     * @param {*} el 新建的和状态对应的Dom节点\r\n     * @param {*} state 当前操作的状态\r\n     */\r\n    saveStateBlockDataInDom(el, state) {\r\n        console.log(state);\r\n        switch (state.stateType) {\r\n            case 'stateDiv': //状态执行\r\n                this.saveStateXY(el, state);\r\n                this.saveStateWidthHeight(el, state);\r\n                this.saveStateMode(el, state);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    },\r\n    /**\r\n     * 保存连线数据到Dom\r\n     * @param {*} el 新建的和状态对应的Dom节点\r\n     * @param {*} state 当前操作的状态\r\n     */\r\n    saveLineData(el, line) {\r\n        el.setAttribute(\"s_type\", line.type);\r\n    },\r\n    /**\r\n     * 将一个状态块转为Dom节点\r\n     * @param {*} rootState \r\n     * @param {*} threadData \r\n     */\r\n    state2dom(rootState, threadData) {\r\n        let rootEl = this.createEl(\"block\");\r\n        // rootEl.setAttribute(\"id\", rootState.stateId);\r\n        rootEl.setAttribute(\"type\", this.genBlockType(rootState.stateType));\r\n        this.saveStateBlockDataInDom(rootEl, rootState);\r\n\r\n\r\n        let fieldDom = this.createFieldDom({\r\n            id: rootState.stateId,\r\n            name: \"field_state\",\r\n            value: rootState.name,\r\n        });\r\n        rootEl.appendChild(fieldDom);\r\n\r\n        let nextStatesDom = this.createNextStatesDom2(rootState, threadData);\r\n        if (nextStatesDom) {\r\n            rootEl.appendChild(nextStatesDom);\r\n        }\r\n        return rootEl;\r\n    },\r\n    /**\r\n     * 创建线程定义块的Dom\r\n     * @param {*} thread \r\n     * @param {*} threadProcedureId 线程的函数id\r\n     */\r\n    createThreadDefDom(thread, threadProcedureId) {\r\n        /* <block type=\"thread_def\" id=\"ISJ:}kp8l):hy~wr5{x5\" x=\"-187\" y=\"-87\">\r\n            <field name=\"NAME\">thread</field>\r\n            <statement name=\"CALLBACK\">\r\n                <block type=\"procedure_select\" id=\"IK`|)2n6nVKsvFJ4VlXC\">\r\n                    <field name=\"field_procedure\" id=\"aewyJ+/)D`VHlrJ$BgFT\">thread_p</field>\r\n                </block>\r\n            </statement>\r\n        </block> */\r\n        // const procedureDefId = this.genUid();\r\n        let threadDefDom = this.createEl('block', {\r\n            type: \"thread_def\"\r\n        });\r\n        let fieldDom = this.createEl('field', {\r\n            name: 'NAME',\r\n            textContent: thread.name\r\n        });\r\n        fieldDom.textContent = thread.name;\r\n\r\n        let statementDom = this.createEl('statement', {\r\n            name: 'CALLBACK'\r\n        });\r\n        let procedureSelectBlockDom = this.createEl('block', {\r\n            type: 'procedure_select'\r\n        });\r\n        let fieldProcedureDom = this.createEl('field', {\r\n            name: 'field_procedure',\r\n            id: threadProcedureId,\r\n        });\r\n        fieldProcedureDom.textContent = thread.name + \"_function\";\r\n        procedureSelectBlockDom.appendChild(fieldProcedureDom);\r\n        statementDom.appendChild(procedureSelectBlockDom);\r\n        threadDefDom.appendChild(fieldDom);\r\n        threadDefDom.appendChild(statementDom);\r\n\r\n        return threadDefDom;\r\n    },\r\n    /**\r\n     * 创建线程函数定义块的Dom\r\n     * @param {*} thread \r\n     * @param {*} threadProcedureId \r\n     * @param {*} statesDom 所有连接的状态\r\n     */\r\n    createThreadProcedureDom(thread, threadProcedureId, statesDom) {\r\n        console.log('---thread.name---' + thread.name);\r\n        /* <block type=\"procedures_defnoreturn\" id=\"aewyJ+/)D`VHlrJ$BgFT\" x=\"463\" y=\"-113\">\r\n            <field name=\"NAME\">thread_p</field>\r\n            <comment pinned=\"false\" h=\"80\" w=\"160\">Describe this function...</comment>\r\n            <statement name=\"STACK\">\r\n            </statement>\r\n        </block> */\r\n        let threadProcedureDom = this.createEl('block', {\r\n            type: 'procedures_defnoreturn',\r\n            id: threadProcedureId\r\n        });\r\n        let fieldDom = this.createEl('field', {\r\n            name: 'NAME',\r\n\r\n        });\r\n        fieldDom.textContent = thread.name + \"_function\";\r\n        let statementDom = this.createEl('statement', {\r\n            name: 'STACK'\r\n        });\r\n        statementDom.appendChild(statesDom);\r\n        threadProcedureDom.appendChild(fieldDom);\r\n        threadProcedureDom.appendChild(statementDom);\r\n        return threadProcedureDom;\r\n    },\r\n    /**\r\n     * 获取唯一id，同google blockly产生唯一id的方法\r\n     */\r\n    genUid() {\r\n        var length = 20;\r\n        var soupLength = SOUP.length;\r\n        var id = [];\r\n        for (var i = 0; i < length; i++) {\r\n            id[i] = SOUP.charAt(Math.random() * soupLength);\r\n        }\r\n        return id.join('');\r\n    },\r\n    getDomChildren(dom) {\r\n        var ary = [];\r\n        if (dom.children) {\r\n            ary = Array.prototype.slice.call(dom.children);\r\n        }\r\n        return ary;\r\n    },\r\n    toNum(str) {\r\n        return parseInt(str, 10);\r\n    },\r\n    translatePX2Num(str) {\r\n        if (/px/.test(str)) {\r\n            str = str.replace(\"px\", \"\");\r\n        }\r\n        return +str;\r\n    },\r\n    getPrevStateDom(dom) {\r\n        var parent = dom.parentNode;\r\n        if (parent) {\r\n            if (parent.getAttribute('type') === 'state_opr') {\r\n                return parent;\r\n            } else {\r\n                parent = this.getPrevStateDom(parent);\r\n            }\r\n        }\r\n        return parent;\r\n    },\r\n    getStateXY(stateDom, existStates) {\r\n        /**\r\n         * 1.获取这个Dom节点的sx, sy值，如果存在就使用这个值，如果不存在，则获取上一个状态的sx, sy值，然后查看这个stateDom处于上一个状态的outputAry中的第几个元素，假设是第3个，则\r\n         * XY的值为：  x: targetDom.sx + gap_x(水平方向间隔)  y: targetDom.sx + index * gap_y\r\n         */\r\n        const gap_x = 150;\r\n        const gap_y = 100;\r\n        let x = this.toNum(stateDom.getAttribute('sx'));\r\n        let y = this.toNum(stateDom.getAttribute('sy'));\r\n\r\n        function getLineDom(dom) {\r\n            var parent = dom.parentNode;\r\n            if (parent) {\r\n                if (parent.getAttribute && parent.getAttribute('type') === 'state_trigger_event') {\r\n                    return parent;\r\n                } else {\r\n                    parent = getLineDom(parent);\r\n                }\r\n            }\r\n            return parent;\r\n        }\r\n\r\n        let prevLineId = getLineDom(stateDom) && getLineDom(stateDom).getAttribute('id');\r\n        // 正常拼接的情况下这个prevLineId是一定存在的\r\n        if (!x || x === 'undefined') { // x是未定义的则 y也是未定义的\r\n            let prevStateDom = Util.getPrevStateDom(stateDom);\r\n            if (!prevStateDom) {\r\n                return {\r\n                    x: 0,\r\n                    y: 0\r\n                }\r\n            }\r\n            let prevX = this.toNum(prevStateDom.getAttribute('sx'));\r\n            let prevY = this.toNum(prevStateDom.getAttribute('sy'));\r\n            if (!prevX || prevX === 'undefined') {\r\n                prevX = 0;\r\n                prevY = 0;\r\n            }\r\n            x = prevX + gap_x;\r\n            var index = 0;\r\n            var prevState = existStates.find(item => {\r\n                return item.stateId === Util.getEntityStateId(prevStateDom);\r\n            })\r\n\r\n            prevState.outputAry.forEach((item, i) => {\r\n                if (item.lineId === prevLineId) {\r\n                    index = i;\r\n                    return false; // return false 结束forEach\r\n                }\r\n            })\r\n            y = prevY + index * gap_y;\r\n        }\r\n        return {\r\n            x: x,\r\n            y: y\r\n        }\r\n    },\r\n    getEntityStateId(stateDom) {\r\n        return stateDom.children[0].getAttribute('id');\r\n    },\r\n    /**\r\n     * 将所有线程的数据（包括了状态和连线）转为Blockly可识别的xml数据\r\n     * @param {*} threadAry 线程数据\r\n     */\r\n    state2blockly(threadAry) {\r\n        /**\r\n         * 1.找到线程中有开始标记的根状态\r\n         * 2.遍历根状态的output，生成特殊的if-else if 结构，注意：默认不采用else\r\n         *\r\n         */\r\n        let statePageData = threadAry;\r\n\r\n        let blocklyXml = Util.createEl(\"xml\");\r\n        blocklyXml.setAttribute(\r\n            \"xmlns\",\r\n            \"https://developers.google.com/blockly/xml\"\r\n        );\r\n\r\n        statePageData.forEach((thread, index) => {\r\n            let firstState = thread.stateAry[0];\r\n            let listsDom = Util.createEl('block');\r\n            listsDom.setAttribute('type', 'lists_state');\r\n            listsDom.setAttribute('x', 300 + (700 * index));\r\n            listsDom.setAttribute('y', 150);\r\n\r\n            let mutationDom = Util.createEl('mutation');\r\n            mutationDom.setAttribute('items', thread.stateAry.length);\r\n            listsDom.appendChild(mutationDom);\r\n\r\n            thread.stateAry.forEach((state, i) => {\r\n                let stateDefBlock = Util.createStateDefBlock(state, i, thread);\r\n                listsDom.appendChild(stateDefBlock);\r\n                // blocklyXml.appendChild(stateDefBlock);\r\n            })\r\n            var statesDom = Util.state2dom(firstState, thread);\r\n            const procedureDefId = Util.genUid();\r\n            let threadDefDom = Util.createThreadDefDom(thread, procedureDefId);\r\n            let threadProcedureDom = Util.createThreadProcedureDom(thread, procedureDefId, statesDom);\r\n            if (Util.isDefined(thread.x)) {\r\n                threadDefDom.setAttribute('x', thread.x);\r\n            } else {\r\n                threadDefDom.setAttribute('x', index * 700);\r\n            }\r\n            if (Util.isDefined(thread.y)) {\r\n                threadDefDom.setAttribute('y', thread.y);\r\n            } else {\r\n                threadDefDom.setAttribute('y', 10);\r\n            }\r\n            threadProcedureDom.setAttribute('x', index * 700);\r\n            threadProcedureDom.setAttribute('y', 200);\r\n            //这个添加的顺序很重要！！！\r\n            blocklyXml.appendChild(listsDom);\r\n            blocklyXml.appendChild(threadProcedureDom);\r\n            blocklyXml.appendChild(threadDefDom);\r\n        });\r\n\r\n        return blocklyXml.outerHTML;\r\n    },\r\n    /**\r\n     * 将Blockly数据转为状态图可识别的数据\r\n     */\r\n    blockly2state(xmlDom) {\r\n        if (typeof xmlDom === 'string') {\r\n            xmlDom = new DOMParser().parseFromString(xmlDom, 'text/xml');\r\n        }\r\n\r\n        var stateLogicDom = Util.getProceduresDefDom(xmlDom);\r\n        var listStateDom = Util.getListStateDom(xmlDom);\r\n\r\n        let stateAry = []; //所有的状态数据集合\r\n        let lineAry = []; //所有的连线数据集合\r\n        Util.extractStateAndLine(stateLogicDom, stateAry, lineAry);\r\n\r\n        Util.updateChildrenOfState(stateAry, listStateDom, lineAry);\r\n        return {\r\n            stateAry: stateAry,\r\n            lineAry: lineAry\r\n        }\r\n    },\r\n    extractStateAndLine(stateDom, stateAry, lineAry) {\r\n        /* <block type=\"state_opr\" id=\"0eRjWo`*LW!O%5)$3!bj\" sx=\"394\" sy=\"201\">\r\n            <field name=\"field_state\" id=\"state-1607658086399\">状态描述0</field>\r\n        </block> */\r\n        const STATE_BLOCK = 'state_opr';\r\n        if (stateDom && stateDom.tagName === 'block' && stateDom.getAttribute('type') === STATE_BLOCK) {\r\n            let stateId = Util.getEntityStateId(stateDom);\r\n            let existThisStateObj = false;\r\n            // 这个stateId有可能已经存在 看一下xml数据就能明白了\r\n            let stateObj = stateAry.find(item => {\r\n                return item.stateId === stateId;\r\n            });\r\n\r\n            if (!stateObj) {\r\n                stateObj = {\r\n                    stateId: Util.getEntityStateId(stateDom), //!!!这里的id不是block.state_opr的 id 哟，而是它下面的field.field_state的id\r\n                    stateType: stateDom.getAttribute('type') === STATE_BLOCK ? 'stateDiv' : 'loopDiv',\r\n                    bx: parseInt(stateDom.getAttribute('x'), 10), // blockly中与此对应的图形块的x\r\n                    by: parseInt(stateDom.getAttribute('y'), 10), // blockly中与此对应的图形块的y\r\n                    x: Util.getStateXY(stateDom, stateAry).x, //stateDom.getAttribute('sx'),\r\n                    y: Util.getStateXY(stateDom, stateAry).y,\r\n                    width: stateDom.getAttribute('s_width') || '76px',\r\n                    height: stateDom.getAttribute('s_height') || '40px',\r\n                    // virtualHeight: Util.getVirtualHeight(outputAry), //TODO 开始状态为这个stateDom的所有状态高度之和\r\n                    name: stateDom.children[0].textContent,\r\n                    mode: stateDom.getAttribute('mode') || 'default',\r\n                    inputAry: [],\r\n                    outputAry: [],\r\n                    children: [],\r\n                    parent: null,\r\n                    nodeHeight: 0 // 如果该节点有2个分支，且分支是叶子节点，则这个节点的nodeHeight = 2; 总之，nodeHeight = 各分支nodeHeight之和 - 这个参数为自动布局所用\r\n                }\r\n                \r\n            }else{\r\n                //如果stateAry里面已经有了这个stateObj且stateObj.outputAry非空  则说明分析过了，不用再调用findOutputLinesOfStateDom进行分析\r\n                /* if (!stateObj.outputAry.length){\r\n                    findOutputLinesOfStateDom(stateDom, stateObj.outputAry);\r\n                }\r\n                if (!stateObj.inputAry.length) {\r\n                    findInputLinesOfStateDom(stateDom, stateObj.inputAry);\r\n                }    */             \r\n                \r\n            }\r\n            findOutputLinesOfStateDom(stateDom, stateObj.outputAry);\r\n            findInputLinesOfStateDom(stateDom, stateObj.inputAry);\r\n\r\n            function dom2State(dom) {\r\n                let stateId = dom.getAttribute('id');\r\n                if (dom.getAttribute('type') === STATE_BLOCK) {\r\n                    stateId = Util.getEntityStateId(dom);\r\n                }\r\n                return {\r\n                    stateId: stateId,\r\n                    stateType: STATE_BLOCK\r\n                };\r\n            }\r\n\r\n            function findOutputLinesOfStateDom(stateDom, outputLines) {\r\n                // 如果stateDom中有next节点 且 next节点的children中有block.state_trigger_event 则将这个block.state_trigger_event push 到 outputLines\r\n                // 然后将这个block.state_trigger_event作为新的stateDom，查找其包含的block.state_trigger_event 这样遍历查找所有的block.state_trigger_event就找到了outputLines\r\n                let children = Util.getDomChildren(stateDom);\r\n                children.forEach(child => {\r\n                    if (child.tagName === 'next') { //所有next节点的children都只有1个\r\n                        if (child.children && child.children[0] && child.children[0].getAttribute('type') === 'state_trigger_event') {\r\n                            let lineDom = child.children[0];\r\n                            if(!lineDom.getAttribute('id').indexOf('line') === 0){\r\n                                debugger;\r\n                            }\r\n                            let newLine = {\r\n                                lineId: lineDom.getAttribute('id'),\r\n                                d: lineDom.getAttribute('d'),\r\n                                type: lineDom.getAttribute('s_type'),\r\n                                startState: dom2State(Util.getStartStateDomOfLine(lineDom)),\r\n                                endState: dom2State(Util.getEndStateDomOfLine(lineDom)),\r\n                            };\r\n                            if (newLine.lineId.indexOf('line') !== 0) {\r\n                                debugger;\r\n                            }\r\n                            let existLineOfOutputLines = outputLines.find(item => {\r\n                                return item.lineId === lineDom.getAttribute('id');\r\n                            })\r\n                            if (!existLineOfOutputLines) {\r\n                                outputLines.push(newLine);\r\n                            }\r\n\r\n                            let existLineOfLineAry = lineAry.find(item => {\r\n                                return (item.lineId === lineDom.getAttribute('id')) || ((item.startState.stateId === newLine.startState.stateId) && (item.endState.stateId === newLine.endState.stateId) )\r\n                            })\r\n                            if (!existLineOfLineAry) {\r\n                                lineAry.push(newLine);\r\n                            }\r\n                            findOutputLinesOfStateDom(lineDom, outputLines);\r\n                        }\r\n                    }\r\n                })\r\n                return outputLines;\r\n            }\r\n\r\n            function findInputLinesOfStateDom(stateDom, inputLines) {\r\n                //逐级往上寻找type === 'state_opr'的块即inputLines    //  block.state_trigger_event > statement > block.state_opr\r\n                let lineDom = stateDom.parentNode && stateDom.parentNode.parentNode;\r\n                if (lineDom && lineDom.getAttribute('type') === 'state_trigger_event') {\r\n                    let newLine = {\r\n                        lineId: lineDom.getAttribute('id'),\r\n                        d: lineDom.getAttribute('d'),\r\n                        type: lineDom.getAttribute('s_type'),\r\n                        startState: dom2State(Util.getPrevStateDom(lineDom)),\r\n                        endState: dom2State(Util.getEndStateDomOfLine(lineDom))\r\n                    };\r\n                    if(newLine.lineId.indexOf('line') !== 0){\r\n                        debugger;\r\n                    }\r\n\r\n                    let existLineOfInputLines = inputLines.find(item => {\r\n                        return item.lineId === newLine.lineId;\r\n                    })\r\n                    if (!existLineOfInputLines) {\r\n                        inputLines.push(newLine);\r\n                    }\r\n\r\n                    let existLineOfLineAry = lineAry.find(item => {\r\n                        return (item.lineId === lineDom.getAttribute('id')) || ((item.startState.stateId === newLine.startState.stateId) && (item.endState.stateId === newLine.endState.stateId))\r\n                    })\r\n                    if (!existLineOfLineAry) {\r\n                        lineAry.push(newLine);\r\n                    }\r\n                }\r\n                return inputLines;\r\n            }\r\n\r\n            let existStateInStateAry = stateAry.find(state => {\r\n                return state.stateId === stateObj.stateId;\r\n            })\r\n            if (!existStateInStateAry) {\r\n                stateAry.push(stateObj);\r\n            }\r\n        }\r\n\r\n        if (stateDom && stateDom.children && stateDom.children.length) {\r\n            for (let j = 0; j < stateDom.children.length; j++) {\r\n                let child = stateDom.children[j];\r\n                Util.extractStateAndLine(child, stateAry, lineAry);\r\n            }\r\n        }\r\n    },\r\n    updateChildrenOfState(stateAry, xmlDom, lineAry) {\r\n        if (xmlDom && xmlDom.tagName === 'block' && xmlDom.getAttribute('type') === 'state_def') {\r\n            if (xmlDom.childNodes) {\r\n                var ary = Array.prototype.slice.call(xmlDom.childNodes);\r\n                var subStatesDom = ary.find(element => {\r\n                    return element.tagName === 'statement'\r\n                });\r\n                if (subStatesDom) {\r\n                    var stateAry2 = [];\r\n                    var childrenData = Util.extractStateAndLine(subStatesDom, stateAry2, lineAry);\r\n                    var state = Util.getStateById(stateAry, xmlDom.getAttribute('id'));\r\n                    if (state) {\r\n                        state.children = stateAry2;\r\n                        stateAry2.forEach(item => {\r\n                            item.parent = state.stateId;\r\n                        })\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            if (xmlDom) {\r\n                var ary2 = Array.prototype.slice.call(xmlDom.childNodes);\r\n                ary2.forEach(item => {\r\n                    Util.updateChildrenOfState(stateAry, item, lineAry);\r\n                })\r\n            }\r\n\r\n        }\r\n\r\n    },\r\n    getProceduresDefDom(dom) {\r\n        var result;\r\n        if (dom.tagName === 'block' && dom.getAttribute('type') === 'procedures_defnoreturn') {\r\n            result = dom;\r\n        } else {\r\n            var children = Array.prototype.slice.call(dom.childNodes);\r\n            for (var i = 0; i < children.length; i++) {\r\n                result = Util.getProceduresDefDom(children[i]);\r\n                if (result) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    },\r\n    getListStateDom(dom) {\r\n        var result;\r\n        if (dom && dom.tagName && dom.tagName === 'block' && dom.getAttribute('type') === 'lists_state') {\r\n            result = dom;\r\n        } else {\r\n            var children = Array.prototype.slice.call(dom.childNodes);\r\n            for (var i = 0; i < children.length; i++) {\r\n                result = Util.getListStateDom(children[i]);\r\n                if (result) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    },\r\n    getStateById(stateAry, stateId) {\r\n        var item, result;\r\n        for (var i = 0; i < stateAry.length; i++) {\r\n            item = stateAry[i];\r\n            if (item.stateId === stateId) {\r\n                return item;\r\n            } else {\r\n                if (item.children && item.children.length) {\r\n                    result = Util.getStateById(item.children, stateId);\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    },\r\n    getStartStateDomOfLine(lineDom) {\r\n        return this.getPrevStateDom(lineDom);\r\n    },\r\n    getEndStateDomOfLine(lineDom) {\r\n        let children = Array.prototype.slice.call(lineDom.childNodes);\r\n        let statement = children.find(dom => {\r\n            return dom.nodeName === 'statement'\r\n        })\r\n        let statementChildren = Array.prototype.slice.call(statement.childNodes);\r\n        let endStateDom = statementChildren.find(dom => {\r\n            return dom.nodeName === 'block'\r\n        })\r\n        if (!endStateDom) {\r\n            console.error('数据错误：触发事件连线没有连接正确的状态');\r\n        }\r\n        return endStateDom;\r\n    },\r\n    /**\r\n     * 将Blockly数据复制到剪切板 - 调试时用\r\n     * @param {*} blocklyXml \r\n     */\r\n    copyBlocklyXml2Clipboard(blocklyXml) {\r\n        // window.stateDataXml = blocklyXml.outerHTML;\r\n        let hiddenInput = document.createElement(\"input\");\r\n        hiddenInput.setAttribute(\"type\", \"text\");\r\n        hiddenInput.setAttribute(\"value\", blocklyXml);\r\n        hiddenInput.setAttribute(\"style\", \"height: 0; overflow: hidden;\");\r\n        document.body.appendChild(hiddenInput);\r\n        //hiddenInput.focus();\r\n        hiddenInput.select();\r\n        document.execCommand(\"copy\");\r\n        document.body.removeChild(hiddenInput);\r\n    },\r\n    workspace2dom() {\r\n        var xmlText = '';\r\n        var iframeDom = document.getElementById('blocklyIframe');\r\n        if (iframeDom) {\r\n            var win = iframeDom.contentWindow;\r\n            var xmlDom = win.Blockly.Xml.workspaceToDom(win.Code.workspace);\r\n            xmlText = win.Blockly.Xml.domToPrettyText(xmlDom);\r\n\r\n        } else {\r\n            console.error('当前页面没有嵌入blockly');\r\n        }\r\n        return xmlText;\r\n    },\r\n    /**\r\n     * 在自动布局前重置所有状态的x,y坐标\r\n     */\r\n    resetAllStateData(thread) {\r\n        if (thread) {\r\n            thread.stateAry.forEach(state => {\r\n                state.x = 0;\r\n                state.y = 0;\r\n            })\r\n        }\r\n    },\r\n    autoLayout(thread) {\r\n        if (thread) {\r\n            let firstState = Util.findFirstState(thread.stateAry);\r\n            thread.stateAry.forEach(state => {\r\n                let prevState; //TODO 当前状态的前一个兄弟节点\r\n                state.virtualHeight = Util.getVirtualHeight(state);\r\n                state.y = prevState.y + prevState.virtualHeight;\r\n            })\r\n        }\r\n    },\r\n    /**\r\n     * 找到“开始状态”\r\n     */\r\n    findFirstState(stateAry) {\r\n        return stateAry[0]; //TODO 后续根据特定标记查找\r\n    },\r\n    getVirtualHeight(state) {\r\n        let outputStates = [];\r\n        state.outputAry.forEach(line => {\r\n            let lineObj = thread.lineAry.find(item => {\r\n                return item.lineId === line.lineId;\r\n            })\r\n            let endStateOfLine = thread.stateAry.find(item => {\r\n                return item.stateId === lineObj.endState.stateId;\r\n            })\r\n            outputStates.push(endStateOfLine);\r\n        })\r\n\r\n        let sum = 0;\r\n        outputStates.forEach(state => {\r\n            if (!state.virtualHeight) {\r\n                state.virtualHeight = Util.getVirtualHeight(state);\r\n                sum += state.virtualHeight;\r\n            }\r\n        })\r\n        return sum;\r\n    },\r\n    getAutoXY(state) {\r\n        //x,y是同时设置的，所以只需判断其中一个即可\r\n        if (state.y) {\r\n            return {\r\n                x: state.x,\r\n                y: state.y\r\n            }\r\n        } else {\r\n            state.y = prevState.y + prevState.virtualHeight;\r\n        }\r\n    },\r\n    getDomByStateId(stateId) {\r\n        let doms = document.getElementsByClassName('state-wrap');\r\n        return Array.prototype.slice.call(doms).find(item => {\r\n            return item.getAttribute('stateid') === stateId;\r\n        })\r\n    },\r\n    /**\r\n     * 根据当前所在的层级生成用于自动布局的graphlib图\r\n     * NOTE: 当前寻找state的代码为hardcode，需要讨论如何在statePage内获取当前线程的Index后修改\r\n     * @param {*} layer \r\n     * @param {*} lineAry \r\n     * \r\n     */\r\n    genGraphByLayer(threadIndex, layer, lineAry) {\r\n        var g = new dagre.graphlib.Graph({\r\n            //multigraph: true,\r\n        });\r\n        g.setGraph({\r\n            rankdir: 'LR',\r\n            align: 'UL',\r\n            edgesep: 0,\r\n            ranksep: RANKSEP,\r\n        });\r\n        g.setDefaultEdgeLabel(function () {\r\n            return {};\r\n        });\r\n        let stateInCurrentLayer\r\n        //获取处于当前所在层级内的状态\r\n        if (layer.stateAry) {\r\n            stateInCurrentLayer = layer.stateAry\r\n        } else {\r\n            stateInCurrentLayer = layer.children\r\n        }\r\n        stateInCurrentLayer.forEach(state => {\r\n            g.setNode(state.stateId, {\r\n                label: state.name,\r\n                width: QBlock.State.getStateWidth(state),\r\n                height: QBlock.State.getStateHeight(state)\r\n            });\r\n            /*\r\n            state.inputAry.forEach(line => {\r\n                let lineObj = lineAry.find(item => {\r\n                    return item.lineId === line.lineId\r\n                })\r\n                let startState = store.getState(threadIndex, lineObj.startState.stateId)\r\n                \r\n                //处理可能存在的从循环状态内连接至循环状态外的连线，若存在这种连线，则将连线起始点模拟到与被连入状态处在同一层级的父状态上\r\n                if (startState.parent !== state.parent) {\r\n                    while (startState.parent !== state.parent) {\r\n                        if (startState.parent === null && startState.parent !== state.parent) {\r\n                            return\r\n                        } else {\r\n                            startState = store.getState(threadIndex, startState.parent)\r\n                        }\r\n                    }\r\n                    g.setEdge(startState.stateId, state.stateId, {\r\n                        label: line.lineId\r\n                    })\r\n                }\r\n            })*/\r\n\r\n            state.outputAry.forEach(line => {\r\n                let lineObj = lineAry.find(item => {\r\n                    return item.lineId === line.lineId;\r\n                })\r\n                let endState = store.getState(threadIndex, lineObj.endState.stateId)\r\n                /*\r\n                if (endState.parent !== state.parent) {\r\n                    //处理可能存在的从循环状态外连接至循环状态内的连线，若存在这种连线，则将连线结束点模拟到与被连入状态处在同一层级的父状态上\r\n                    while (endState.parent !== state.parent) {\r\n                        if (endState.parent === null && endState.parent !== state.parent) {\r\n                            return\r\n                        } else {\r\n                            endState = store.getState(threadIndex, endState.parent)\r\n                        }\r\n                    }\r\n                }*/\r\n                // g.setEdge(state.stateId, endState.stateId, line.lineId, lineObj.desc); //这种设置方式会报错 可能是dagre对graphlib的封装接口未同步\r\n                g.setEdge(state.stateId, endState.stateId, {\r\n                    label: line.lineId\r\n                });\r\n            })\r\n        })\r\n        return g\r\n    },\r\n    setStateXYbyNode(state, node) {\r\n        let halfStateWidth = QBlock.State.getStateWidth(state) / 2\r\n        let halfStateHeight = QBlock.State.getStateHeight(state) / 2\r\n        state.x = node.x - halfStateWidth + 20\r\n        state.y = node.y - halfStateHeight + 20\r\n        return\r\n    },\r\n    setStateXYbyLayer(threadIndex, g, layer) {\r\n        let stateInCurrentLayer\r\n        if (layer.stateAry) {\r\n            stateInCurrentLayer = layer.stateAry\r\n        } else {\r\n            stateInCurrentLayer = layer.children\r\n        }\r\n        g.nodes().forEach(function (nodeId) {\r\n            let node = g.node(nodeId);\r\n            let state = store.getState(threadIndex, nodeId)\r\n            if (state) {\r\n                Util.setStateXYbyNode(state, node) //重设状态位置信息\r\n                if (state.inputAry && state.inputAry.length) {\r\n                    state.inputAry.forEach(item => {\r\n                        store.stateData.lineMap[item.lineId].refresh();\r\n                    })\r\n                }\r\n            }\r\n            console.log(\"Node \" + nodeId + \": \" + JSON.stringify(g.node(nodeId)));\r\n        });\r\n    },\r\n    testLayout(threadIndex, thread, lineAry) {\r\n        //处理在自动布局前被用户所调整过的连线\r\n        let g = this.genGraphByLayer(threadIndex, thread, lineAry)\r\n        dagre.layout(g); //布局分析\r\n        this.setStateXYbyLayer(threadIndex, g, thread)\r\n    },\r\n}\r\nexport default Util;"]}