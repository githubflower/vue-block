{"version":3,"sources":["util.js"],"names":["_dagre","_interopRequireDefault","require","_qblock","NAME_SPACE","SOUP","Util","isDefined","a","createEl","tagName","attrs","dom","document","createElementNS","_typeof","key","setAttribute","createFieldDom","field","container","this","name","id","textContent","value","createCommentDom","comment","commentDom","pinned","createStateDefBlock","state","index","valueDom","stateId","stateDom","appendChild","fieldDom","nextDom","outputDom","outputAry","length","mutation","forEach","outputItem","createNextStatesDom","outputStateDom","_this","concat","lineId","line","lineAry","find","item","stateAry","state2dom","thread","error","triggerEventDom","console","parentDom","createNextStatesDom2","_this2","nextStatesDom","triggerEventStatement","d","desc","endState","JSON","stringify","genBlockType","type","ret","saveStateXY","el","x","y","stateType","startState","rootState","threadData","rootEl","saveStateBlockDataInDom","fieldX","saveLineData","createThreadDefDom","threadProcedureId","statementDom","fieldProcedureDom","procedureSelectBlockDom","threadDefDom","createThreadProcedureDom","statesDom","log","threadProcedureDom","genUid","soupLength","i","charAt","Math","random","join","ary","children","Array","prototype","slice","call","toNum","str","test","replace","getPrevStateDom","parent","parentNode","getStateXY","existStates","getAttribute","getDomChildren","parseInt","getLineDom","translatePX2Num","prevX","prevStateDom","prevY","getEntityStateId","prevLineId","gap_y","state2blockly","threadAry","statePageData","blocklyXml","firstState","listsDom","mutationDom","gap_x","stateDefBlock","prevState","procedureDefId","outerHTML","blockly2state","xmlDom","DOMParser","parseFromString","STATE_BLOCK","dom2State","bx","by","height","inputAry","nodeHeight","findOutputLinesOfStateDom","outputLines","child","lineDom","newLine","getEndStateDomOfLine","push","inputLines","existLineOfOutputLines","findInputLinesOfStateDom","stateObj","j","extractStateAndLine","statement","childNodes","existLineOfLineAry","endStateDom","hiddenInput","createElement","body","width","select","execCommand","removeChild","getElementById","win","iframeDom","contentWindow","Blockly","Xml","workspaceToDom","Code","workspace","xmlText","resetAllStateData","autoLayout","findFirstState","virtualHeight","getVirtualHeight","nodeName","lineObj","endStateOfLine","outputStates","copyBlocklyXml2Clipboard","sum","workspace2dom","getDomByStateId","getElementsByClassName","doms","testLayout","g","dagre","graphlib","Graph","multigraph","setGraph","rankdir","align","edgesep","setNode","label","nodes","nodeId","node","edges","edge","QBlock","Line","redrawLine"],"mappings":"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","file":"util.min.js","sourcesContent":["const NAME_SPACE = \"https://developers.google.com/blockly/xml\";\r\nconst SOUP = '!#$%()*+,-./:;=?@[]^_`{|}~ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\r\n\r\nimport dagre from 'dagre'\r\nimport QBlock from './qblock';\r\n\r\nvar Util = {\r\n    isDefined(a) {\r\n        return !((a === '') || (a === null) || (typeof a === 'undefined'));\r\n    },\r\n    createEl(tagName, attrs) {\r\n        var dom = document.createElementNS(NAME_SPACE, tagName);\r\n        if (typeof attrs === 'object') {\r\n            for (var key in attrs) {\r\n                dom.setAttribute(key, attrs[key]);\r\n            }\r\n        }\r\n        return dom;\r\n    },\r\n    createFieldDom(field) {\r\n        let container = this.createEl(\"field\");\r\n        container.setAttribute(\"name\", field.name);\r\n        if (field.id) {\r\n            container.setAttribute('id', field.id);\r\n        }\r\n        container.textContent = field.value;\r\n        return container;\r\n    },\r\n\r\n    /**\r\n     * 创建注释块Dom\r\n     * @param {*} comment \r\n     */\r\n    createCommentDom(comment) {\r\n        let commentDom = this.createEl('comment');\r\n        commentDom.setAttribute('pinned', comment.pinned || false);\r\n        commentDom.textContent = comment.value;\r\n        return commentDom;\r\n    },\r\n\r\n    /**\r\n     * 创建状态定义块Dom\r\n     * @param {*} state \r\n     * @param {*} index \r\n     */\r\n    createStateDefBlock(state, index) {\r\n        var valueDom = this.createEl('value');\r\n        valueDom.setAttribute('name', 'ADD' + index);\r\n\r\n        var stateDom = this.createEl('block');\r\n        stateDom.setAttribute('type', 'state_def');\r\n        stateDom.setAttribute('id', state.stateId);\r\n        var fieldDom = this.createFieldDom({\r\n            name: 'NAME',\r\n            value: state.name\r\n        });\r\n        stateDom.appendChild(fieldDom);\r\n\r\n        valueDom.appendChild(stateDom);\r\n        return valueDom;\r\n    },\r\n\r\n    /**\r\n     * 创建连线Dom以及其连接的状态块的Dom - 触发事件描述采用通用的if-else结构 controls_if \r\n     * ！此方法没有用到，代码暂时先放着\r\n     * @param {*} state \r\n     * @param {*} thread \r\n     */\r\n    createNextStatesDom(state, thread) {\r\n        let nextDom, outputDom;\r\n\r\n        if (state.outputAry.length) {\r\n            nextDom = this.createEl(\"next\");\r\n            outputDom = this.createEl(\"block\");\r\n            outputDom.setAttribute(\"type\", \"controls_if\");\r\n            if (state.outputAry.length > 1) {\r\n                let mutation = this.createEl(\"mutation\");\r\n                mutation.setAttribute(\"elseif\", state.outputAry.length - 1);\r\n                outputDom.appendChild(mutation);\r\n            }\r\n            state.outputAry.forEach((outputItem, index) => {\r\n                let outputStateDom;\r\n                outputStateDom = this.createEl(\"statement\");\r\n                outputStateDom.setAttribute(\"name\", `DO${index}`);\r\n                outputStateDom.setAttribute(\"id\", `${outputItem.lineId}`);\r\n                //outputAry里面只存放了lineId 所以我们需要做以下事情：\r\n                //1 根据lineId找到对应的line数据\r\n                //2 根据line里面的endState的stateId找到对应的state数据\r\n                let line = thread.lineAry.find((item) => {\r\n                    return item.lineId === outputItem.lineId;\r\n                });\r\n                if (line) {\r\n                    let state = thread.stateAry.find((item) => {\r\n                        return item.stateId === line.endState.stateId;\r\n                    });\r\n                    if (state) {\r\n                        outputStateDom.appendChild(Util.state2dom(state, thread));\r\n                    } else {\r\n                        console.error(\"data error -^- \");\r\n                    }\r\n                }\r\n                if (outputStateDom) {\r\n                    outputDom.appendChild(outputStateDom);\r\n                }\r\n            });\r\n            nextDom.appendChild(outputDom);\r\n        }\r\n        return nextDom;\r\n    },\r\n\r\n    /**\r\n     * 创建连线Dom以及其连接的状态块的Dom - 触发事件描述采用独立的结构 state_trigger_event\r\n     * @param {*} state \r\n     * @param {*} thread \r\n     */\r\n    createNextStatesDom2(state, thread) {\r\n        let triggerEventDom;\r\n        let nextStatesDom;\r\n        if (state.outputAry.length) {\r\n            /* if (state.outputAry.length > 1) {\r\n                let mutation = this.createEl(\"mutation\");\r\n                mutation.setAttribute(\"elseif\", state.outputAry.length - 1);\r\n                triggerEventDom.appendChild(mutation);\r\n            } */\r\n            let parentDom;\r\n\r\n            state.outputAry.forEach((outputItem, index) => {\r\n                let nextDom = this.createEl(\"next\");\r\n                if (!nextStatesDom) {\r\n                    nextStatesDom = nextDom;\r\n                }\r\n                triggerEventDom = this.createEl(\"block\");\r\n                triggerEventDom.setAttribute(\"type\", \"state_trigger_event\");\r\n                triggerEventDom.setAttribute(\"id\", outputItem.lineId);\r\n                // triggerEventDom.setAttribute(\"start_state\", JSON.stringify(state)); // TODO 按需简化存储的start_state数据\r\n\r\n                let triggerEventStatement;\r\n                triggerEventStatement = this.createEl(\"statement\");\r\n                triggerEventStatement.setAttribute(\"name\", `DO0`);\r\n                // triggerEventStatement.setAttribute(\"id\", `${outputItem.lineId}`);\r\n                //outputAry里面只存放了lineId 所以我们需要做以下事情：\r\n                //1 根据lineId找到对应的line数据\r\n                //2 根据line里面的endState的stateId找到对应的state数据\r\n                let line = thread.lineAry.find((item) => {\r\n                    return item.lineId === outputItem.lineId;\r\n                });\r\n                if (line) {\r\n                    triggerEventDom.setAttribute(\"d\", line.d);\r\n                    if (line.desc) {\r\n                        let commentDom = this.createCommentDom({\r\n                            value: line.desc\r\n                        });\r\n                        triggerEventDom.appendChild(commentDom);\r\n                    }\r\n                    let state = thread.stateAry.find((item) => {\r\n                        return item.stateId === line.endState.stateId;\r\n                    });\r\n                    if (state) {\r\n                        triggerEventDom.setAttribute(\"end_state\", JSON.stringify(state)); // TODO 按需简化存储的end_state数据\r\n                        triggerEventStatement.appendChild(Util.state2dom(state, thread));\r\n                    } else {\r\n                        console.error(\"data error -^- \");\r\n                    }\r\n                }\r\n                if (triggerEventStatement) {\r\n                    triggerEventDom.appendChild(triggerEventStatement);\r\n                }\r\n                nextDom.appendChild(triggerEventDom);\r\n                if (parentDom) {\r\n                    parentDom.appendChild(nextDom);\r\n                }\r\n                parentDom = triggerEventDom;\r\n\r\n            });\r\n        }\r\n        return nextStatesDom;\r\n    },\r\n\r\n    genBlockType(type) {\r\n        let ret = \"state_opr\";\r\n        if (type === \"loopDiv\") {\r\n            ret = \"controls_whileUntil\";\r\n        }\r\n        return ret;\r\n    },\r\n    /**\r\n     * 保存状态块的位置信息到Dom中\r\n     * @param {*} el 新建的和状态对应的Dom节点\r\n     * @param {*} state 当前操作的状态\r\n     */\r\n    saveStateXY(el, state) {\r\n        el.setAttribute(\"sx\", state.x);\r\n        el.setAttribute(\"sy\", state.y);\r\n    },\r\n    /**\r\n     * 保存状态块的数据到Dom中\r\n     * @param {*} el 新建的和状态对应的Dom节点\r\n     * @param {*} state 当前操作的状态\r\n     */\r\n    saveStateBlockDataInDom(el, state) {\r\n        switch (state.stateType) {\r\n            case 'stateDiv': //状态执行\r\n                this.saveStateXY(el, state);\r\n                break;\r\n            case 'state_trigger_event': //连线\r\n                this.saveLineData(el, state);\r\n            default:\r\n                break;\r\n        }\r\n    },\r\n    /**\r\n     * 保存连线数据到Dom\r\n     * @param {*} el 新建的和状态对应的Dom节点\r\n     * @param {*} state 当前操作的状态\r\n     */\r\n    saveLineData(el, state) {\r\n        el.setAttribute(\"d\", state.d);\r\n        el.setAttribute(\"start_state\", JSON.stringify(state.startState));\r\n        el.setAttribute(\"end_state\", JSON.stringify(state.startState));\r\n    },\r\n    /**\r\n     * 将一个状态块转为Dom节点\r\n     * @param {*} rootState \r\n     * @param {*} threadData \r\n     */\r\n    state2dom(rootState, threadData) {\r\n        let rootEl = this.createEl(\"block\");\r\n        console.log(\r\n            rootState.stateId +\r\n            \" --- \" +\r\n            rootState.name +\r\n            \" --- \" +\r\n            rootState.stateType\r\n        );\r\n        // rootEl.setAttribute(\"id\", rootState.stateId);\r\n        rootEl.setAttribute(\"type\", this.genBlockType(rootState.stateType));\r\n        this.saveStateBlockDataInDom(rootEl, rootState);\r\n\r\n\r\n        let fieldDom = this.createFieldDom({\r\n            id: rootState.stateId,\r\n            name: \"field_state\",\r\n            value: rootState.name,\r\n        });\r\n        rootEl.appendChild(fieldDom);\r\n\r\n        let fieldX = this.createFieldDom({\r\n            id: rootState.stateId,\r\n            name: \"SX_FIELD\",\r\n            value: 8888 //rootState.x,\r\n        });\r\n        rootEl.appendChild(fieldX);\r\n\r\n        let nextStatesDom = this.createNextStatesDom2(rootState, threadData);\r\n        if (nextStatesDom) {\r\n            rootEl.appendChild(nextStatesDom);\r\n        }\r\n        return rootEl;\r\n    },\r\n    /**\r\n     * 创建线程定义块的Dom\r\n     * @param {*} thread \r\n     * @param {*} threadProcedureId 线程的函数id\r\n     */\r\n    createThreadDefDom(thread, threadProcedureId) {\r\n        /* <block type=\"thread_def\" id=\"ISJ:}kp8l):hy~wr5{x5\" x=\"-187\" y=\"-87\">\r\n            <field name=\"NAME\">thread</field>\r\n            <statement name=\"CALLBACK\">\r\n                <block type=\"procedure_select\" id=\"IK`|)2n6nVKsvFJ4VlXC\">\r\n                    <field name=\"field_procedure\" id=\"aewyJ+/)D`VHlrJ$BgFT\">thread_p</field>\r\n                </block>\r\n            </statement>\r\n        </block> */\r\n        // const procedureDefId = this.genUid();\r\n        let threadDefDom = this.createEl('block', {\r\n            type: \"thread_def\"\r\n        });\r\n        let fieldDom = this.createEl('field', {\r\n            name: 'NAME',\r\n            textContent: thread.name\r\n        });\r\n        fieldDom.textContent = thread.name;\r\n\r\n        let statementDom = this.createEl('statement', {\r\n            name: 'CALLBACK'\r\n        });\r\n        let procedureSelectBlockDom = this.createEl('block', {\r\n            type: 'procedure_select'\r\n        });\r\n        let fieldProcedureDom = this.createEl('field', {\r\n            name: 'field_procedure',\r\n            id: threadProcedureId,\r\n        });\r\n        fieldProcedureDom.textContent = thread.name + \"_function\";\r\n        procedureSelectBlockDom.appendChild(fieldProcedureDom);\r\n        statementDom.appendChild(procedureSelectBlockDom);\r\n        threadDefDom.appendChild(fieldDom);\r\n        threadDefDom.appendChild(statementDom);\r\n\r\n        return threadDefDom;\r\n    },\r\n    /**\r\n     * 创建线程函数定义块的Dom\r\n     * @param {*} thread \r\n     * @param {*} threadProcedureId \r\n     * @param {*} statesDom 所有连接的状态\r\n     */\r\n    createThreadProcedureDom(thread, threadProcedureId, statesDom) {\r\n        console.log('---thread.name---' + thread.name);\r\n        /* <block type=\"procedures_defnoreturn\" id=\"aewyJ+/)D`VHlrJ$BgFT\" x=\"463\" y=\"-113\">\r\n            <field name=\"NAME\">thread_p</field>\r\n            <comment pinned=\"false\" h=\"80\" w=\"160\">Describe this function...</comment>\r\n            <statement name=\"STACK\">\r\n            </statement>\r\n        </block> */\r\n        let threadProcedureDom = this.createEl('block', {\r\n            type: 'procedures_defnoreturn',\r\n            id: threadProcedureId\r\n        });\r\n        let fieldDom = this.createEl('field', {\r\n            name: 'NAME',\r\n\r\n        });\r\n        fieldDom.textContent = thread.name + \"_function\";\r\n        let statementDom = this.createEl('statement', {\r\n            name: 'STACK'\r\n        });\r\n        statementDom.appendChild(statesDom);\r\n        threadProcedureDom.appendChild(fieldDom);\r\n        threadProcedureDom.appendChild(statementDom);\r\n        return threadProcedureDom;\r\n    },\r\n    /**\r\n     * 获取唯一id，同google blockly产生唯一id的方法\r\n     */\r\n    genUid() {\r\n        var length = 20;\r\n        var soupLength = SOUP.length;\r\n        var id = [];\r\n        for (var i = 0; i < length; i++) {\r\n            id[i] = SOUP.charAt(Math.random() * soupLength);\r\n        }\r\n        return id.join('');\r\n    },\r\n    getDomChildren(dom) {\r\n        var ary = [];\r\n        if (dom.children) {\r\n            ary = Array.prototype.slice.call(dom.children);\r\n        }\r\n        return ary;\r\n    },\r\n    toNum(str) {\r\n        return parseInt(str, 10);\r\n    },\r\n    translatePX2Num(str) {\r\n        if (/px/.test(str)) {\r\n            str = str.replace(\"px\", \"\");\r\n        }\r\n        return +str;\r\n    },\r\n    getPrevStateDom(dom) {\r\n        var parent = dom.parentNode;\r\n        if (parent) {\r\n            if (parent.getAttribute('type') === 'state_opr') {\r\n                return parent;\r\n            } else {\r\n                parent = this.getPrevStateDom(parent);\r\n            }\r\n        }\r\n        return parent;\r\n    },\r\n    getStateXY(stateDom, existStates) {\r\n        /**\r\n         * 1.获取这个Dom节点的sx, sy值，如果存在就使用这个值，如果不存在，则获取上一个状态的sx, sy值，然后查看这个stateDom处于上一个状态的outputAry中的第几个元素，假设是第3个，则\r\n         * XY的值为：  x: targetDom.sx + gap_x(水平方向间隔)  y: targetDom.sx + index * gap_y\r\n         */\r\n        const gap_x = 150;\r\n        const gap_y = 100;\r\n        let x = this.toNum(stateDom.getAttribute('sx'));\r\n        let y = this.toNum(stateDom.getAttribute('sy'));\r\n\r\n        function getLineDom(dom) {\r\n            var parent = dom.parentNode;\r\n            if (parent) {\r\n                if (parent.getAttribute && parent.getAttribute('type') === 'state_trigger_event') {\r\n                    return parent;\r\n                } else {\r\n                    parent = getLineDom(parent);\r\n                }\r\n            }\r\n            return parent;\r\n        }\r\n\r\n        let prevLineId = getLineDom(stateDom) && getLineDom(stateDom).getAttribute('id');\r\n        // 正常拼接的情况下这个prevLineId是一定存在的\r\n        if (!x || x === 'undefined') { // x是未定义的则 y也是未定义的\r\n            let prevStateDom = Util.getPrevStateDom(stateDom);\r\n            if (!prevStateDom) {\r\n                return {\r\n                    x: 0,\r\n                    y: 0\r\n                }\r\n            }\r\n            let prevX = this.toNum(prevStateDom.getAttribute('sx'));\r\n            let prevY = this.toNum(prevStateDom.getAttribute('sy'));\r\n            if (!prevX || prevX === 'undefined') {\r\n                prevX = 0;\r\n                prevY = 0;\r\n            }\r\n            x = prevX + gap_x;\r\n            var index = 0;\r\n            var prevState = existStates.find(item => {\r\n                return item.stateId === Util.getEntityStateId(prevStateDom);\r\n            })\r\n\r\n            prevState.outputAry.forEach((item, i) => {\r\n                if (item.lineId === prevLineId) {\r\n                    index = i;\r\n                    return false; // return false 结束forEach\r\n                }\r\n            })\r\n            y = prevY + index * gap_y;\r\n        }\r\n        return {\r\n            x: x,\r\n            y: y\r\n        }\r\n    },\r\n    getEntityStateId(stateDom) {\r\n        return stateDom.children[0].getAttribute('id');\r\n    },\r\n    /**\r\n     * 将所有线程的数据（包括了状态和连线）转为Blockly可识别的xml数据\r\n     * @param {*} threadAry 线程数据\r\n     */\r\n    state2blockly(threadAry) {\r\n        /**\r\n         * 1.找到线程中有开始标记的根状态\r\n         * 2.遍历根状态的output，生成特殊的if-else if 结构，注意：默认不采用else\r\n         *\r\n         */\r\n        let statePageData = threadAry;\r\n\r\n        let blocklyXml = Util.createEl(\"xml\");\r\n        blocklyXml.setAttribute(\r\n            \"xmlns\",\r\n            \"https://developers.google.com/blockly/xml\"\r\n        );\r\n\r\n        statePageData.forEach((thread, index) => {\r\n            let firstState = thread.stateAry[0];\r\n            let listsDom = Util.createEl('block');\r\n            listsDom.setAttribute('type', 'lists_state');\r\n            listsDom.setAttribute('x', 300 + (700 * index));\r\n            listsDom.setAttribute('y', 150);\r\n\r\n            let mutationDom = Util.createEl('mutation');\r\n            mutationDom.setAttribute('items', thread.stateAry.length);\r\n            listsDom.appendChild(mutationDom);\r\n\r\n            thread.stateAry.forEach((state, i) => {\r\n                let stateDefBlock = Util.createStateDefBlock(state, i);\r\n                listsDom.appendChild(stateDefBlock);\r\n                // blocklyXml.appendChild(stateDefBlock);\r\n            })\r\n            var statesDom = Util.state2dom(firstState, thread);\r\n            const procedureDefId = Util.genUid();\r\n            let threadDefDom = Util.createThreadDefDom(thread, procedureDefId);\r\n            let threadProcedureDom = Util.createThreadProcedureDom(thread, procedureDefId, statesDom);\r\n            if (Util.isDefined(thread.x)) {\r\n                threadDefDom.setAttribute('x', thread.x);\r\n            } else {\r\n                threadDefDom.setAttribute('x', index * 700);\r\n            }\r\n            if (Util.isDefined(thread.y)) {\r\n                threadDefDom.setAttribute('y', thread.y);\r\n            } else {\r\n                threadDefDom.setAttribute('y', 10);\r\n            }\r\n            threadProcedureDom.setAttribute('x', index * 700);\r\n            threadProcedureDom.setAttribute('y', 200);\r\n            //这个添加的顺序很重要！！！\r\n            blocklyXml.appendChild(listsDom);\r\n            blocklyXml.appendChild(threadProcedureDom);\r\n            blocklyXml.appendChild(threadDefDom);\r\n        });\r\n\r\n        return blocklyXml.outerHTML;\r\n    },\r\n    /**\r\n     * 将Blockly数据转为状态图可识别的数据\r\n     */\r\n    blockly2state(xmlDom) {\r\n        if (typeof xmlDom === 'string') {\r\n            xmlDom = new DOMParser().parseFromString(xmlDom, 'text/xml');\r\n        }\r\n\r\n        const STATE_BLOCK = 'state_opr';\r\n        let stateAry = []; //所有的状态数据集合\r\n        let lineAry = []; //所有的连线数据集合\r\n        function extractStateAndLine(stateDom) {\r\n            /* <block type=\"state_opr\" id=\"0eRjWo`*LW!O%5)$3!bj\" sx=\"394\" sy=\"201\">\r\n                <field name=\"field_state\" id=\"state-1607658086399\">状态描述0</field>\r\n            </block> */\r\n            if (stateDom.tagName === 'block' && stateDom.getAttribute('type') === STATE_BLOCK) {\r\n                let stateObj = {\r\n                    stateId: Util.getEntityStateId(stateDom), //!!!这里的id不是block.state_opr的 id 哟，而是它下面的field.field_state的id\r\n                    stateType: stateDom.getAttribute('type') === STATE_BLOCK ? 'stateDiv' : 'loopDiv',\r\n                    bx: parseInt(stateDom.getAttribute('x'), 10), // blockly中与此对应的图形块的x\r\n                    by: parseInt(stateDom.getAttribute('y'), 10), // blockly中与此对应的图形块的y\r\n                    x: Util.getStateXY(stateDom, stateAry).x, //stateDom.getAttribute('sx'),\r\n                    y: Util.getStateXY(stateDom, stateAry).y,\r\n                    width: '76px',\r\n                    height: '40px',\r\n                    // virtualHeight: Util.getVirtualHeight(outputAry), //TODO 开始状态为这个stateDom的所有状态高度之和\r\n                    name: stateDom.children[0].textContent,\r\n                    inputAry: [],\r\n                    outputAry: [],\r\n                    children: [],\r\n                    nodeHeight: 0 // 如果该节点有2个分支，且分支是叶子节点，则这个节点的nodeHeight = 2; 总之，nodeHeight = 各分支nodeHeight之和 - 这个参数为自动布局所用\r\n                }\r\n\r\n\r\n\r\n                function dom2State(dom) {\r\n                    let stateId = dom.getAttribute('id');\r\n                    if (dom.getAttribute('type') === STATE_BLOCK) {\r\n                        stateId = Util.getEntityStateId(dom);\r\n                    }\r\n                    return {\r\n                        stateId: stateId,\r\n                        stateType: STATE_BLOCK\r\n                    };\r\n                }\r\n\r\n                function findOutputLinesOfStateDom(stateDom, outputLines) {\r\n                    // 如果stateDom中有next节点 且 next节点的children中有block.state_trigger_event 则将这个block.state_trigger_event push 到 outputLines\r\n                    // 然后将这个block.state_trigger_event作为新的stateDom，查找其包含的block.state_trigger_event 这样遍历查找所有的block.state_trigger_event就找到了outputLines\r\n                    let children = Util.getDomChildren(stateDom);\r\n                    children.forEach(child => {\r\n                        if (child.tagName === 'next') { //所有next节点的children都只有1个\r\n                            if (child.children && child.children[0] && child.children[0].getAttribute('type') === 'state_trigger_event') {\r\n                                let lineDom = child.children[0];\r\n                                let newLine = {\r\n                                    lineId: lineDom.getAttribute('id'),\r\n                                    d: lineDom.getAttribute('d'),\r\n                                    startState: dom2State(stateDom),\r\n                                    endState: dom2State(Util.getEndStateDomOfLine(lineDom)),\r\n                                };\r\n\r\n                                let existLineOfOutputLines = outputLines.find(item => {\r\n                                    return item.lineId === lineDom.getAttribute('id');\r\n                                })\r\n                                if (!existLineOfOutputLines) {\r\n                                    outputLines.push(newLine);\r\n                                }\r\n\r\n                                let existLineOfLineAry = lineAry.find(item => {\r\n                                    return item.lineId === lineDom.getAttribute('id')\r\n                                })\r\n                                if (!existLineOfLineAry) {\r\n                                    lineAry.push(newLine);\r\n                                }\r\n                                findOutputLinesOfStateDom(lineDom, outputLines);\r\n                            }\r\n                        }\r\n                    })\r\n                    return outputLines;\r\n                }\r\n\r\n                function findInputLinesOfStateDom(stateDom, inputLines) {\r\n                    //逐级往上寻找type === 'state_opr'的块即inputLines    //  block.state_trigger_event > statement > block.state_opr\r\n                    let lineDom = stateDom.parentNode && stateDom.parentNode.parentNode;\r\n                    if (lineDom && lineDom.getAttribute('type') === 'state_trigger_event') {\r\n                        let newLine = {\r\n                            lineId: lineDom.getAttribute('id'),\r\n                            d: lineDom.getAttribute('d'),\r\n                            startState: dom2State(Util.getPrevStateDom(lineDom)),\r\n                            endState: dom2State(stateDom)\r\n                        };\r\n\r\n                        let existLineOfInputLines = inputLines.find(item => {\r\n                            return item.lineId === newLine.lineId;\r\n                        })\r\n                        if (!existLineOfInputLines) {\r\n                            inputLines.push(newLine);\r\n                        }\r\n\r\n                        let existLineOfLineAry = lineAry.find(item => {\r\n                            return item.lineId === newLine.lineId;\r\n                        })\r\n                        if (!existLineOfLineAry) {\r\n                            lineAry.push(newLine);\r\n                        }\r\n                    }\r\n                    return inputLines;\r\n                }\r\n\r\n                findOutputLinesOfStateDom(stateDom, stateObj.outputAry);\r\n                findInputLinesOfStateDom(stateDom, stateObj.inputAry);\r\n\r\n                let existStateInStateAry = stateAry.find(state => {\r\n                    return state.stateId === stateObj.stateId;\r\n                })\r\n                if (!existStateInStateAry) {\r\n                    stateAry.push(stateObj);\r\n                }\r\n            }\r\n            if (stateDom.children && stateDom.children.length) {\r\n                for (let j = 0; j < stateDom.children.length; j++) {\r\n                    let child = stateDom.children[j];\r\n                    extractStateAndLine(child);\r\n                }\r\n            }\r\n        }\r\n        extractStateAndLine(xmlDom);\r\n        return {\r\n            stateAry: stateAry,\r\n            lineAry: lineAry\r\n        }\r\n    },\r\n    getEndStateDomOfLine(lineDom){\r\n        let children = Array.prototype.slice.call(lineDom.childNodes);\r\n        let statement = children.find(dom => {\r\n            return dom.nodeName === 'statement'\r\n        })\r\n        let statementChildren = Array.prototype.slice.call(statement.childNodes);\r\n        let endStateDom = statementChildren.find(dom => {\r\n            return dom.nodeName === 'block'\r\n        })\r\n        if (!endStateDom){\r\n            console.error('数据错误：触发事件连线没有连接正确的状态');\r\n        }\r\n        return endStateDom;\r\n    },\r\n    /**\r\n     * 将Blockly数据复制到剪切板 - 调试时用\r\n     * @param {*} blocklyXml \r\n     */\r\n    copyBlocklyXml2Clipboard(blocklyXml) {\r\n        // window.stateDataXml = blocklyXml.outerHTML;\r\n        let hiddenInput = document.createElement(\"input\");\r\n        hiddenInput.setAttribute(\"type\", \"text\");\r\n        hiddenInput.setAttribute(\"value\", blocklyXml);\r\n        hiddenInput.setAttribute(\"style\", \"height: 0; overflow: hidden;\");\r\n        document.body.appendChild(hiddenInput);\r\n        hiddenInput.focus();\r\n        hiddenInput.select();\r\n        document.execCommand(\"copy\");\r\n        document.body.removeChild(hiddenInput);\r\n    },\r\n    workspace2dom() {\r\n        var xmlText = '';\r\n        var iframeDom = document.getElementById('blocklyIframe');\r\n        if (iframeDom) {\r\n            var win = iframeDom.contentWindow;\r\n            var xmlDom = win.Blockly.Xml.workspaceToDom(win.Code.workspace);\r\n            xmlText = win.Blockly.Xml.domToPrettyText(xmlDom);\r\n\r\n        } else {\r\n            console.error('当前页面没有嵌入blockly');\r\n        }\r\n        return xmlText;\r\n    },\r\n    /**\r\n     * 在自动布局前重置所有状态的x,y坐标\r\n     */\r\n    resetAllStateData(thread) {\r\n        if (thread) {\r\n            thread.stateAry.forEach(state => {\r\n                state.x = 0;\r\n                state.y = 0;\r\n            })\r\n        }\r\n    },\r\n    autoLayout(thread) {\r\n        if (thread) {\r\n            let firstState = Util.findFirstState(thread.stateAry);\r\n            thread.stateAry.forEach(state => {\r\n                let prevState; //TODO 当前状态的前一个兄弟节点\r\n                state.virtualHeight = Util.getVirtualHeight(state);\r\n                state.y = prevState.y + prevState.virtualHeight;\r\n            })\r\n        }\r\n    },\r\n    /**\r\n     * 找到“开始状态”\r\n     */\r\n    findFirstState(stateAry) {\r\n        return stateAry[0]; //TODO 后续根据特定标记查找\r\n    },\r\n    getVirtualHeight(state) {\r\n        let outputStates = [];\r\n        state.outputAry.forEach(line => {\r\n            let lineObj = thread.lineAry.find(item => {\r\n                return item.lineId === line.lineId;\r\n            })\r\n            let endStateOfLine = thread.stateAry.find(item => {\r\n                return item.stateId === lineObj.endState.stateId;\r\n            })\r\n            outputStates.push(endStateOfLine);\r\n        })\r\n\r\n        let sum = 0;\r\n        outputStates.forEach(state => {\r\n            if (!state.virtualHeight) {\r\n                state.virtualHeight = Util.getVirtualHeight(state);\r\n                sum += state.virtualHeight;\r\n            }\r\n        })\r\n        return sum;\r\n    },\r\n    getAutoXY(state) {\r\n        //x,y是同时设置的，所以只需判断其中一个即可\r\n        if (state.y) {\r\n            return {\r\n                x: state.x,\r\n                y: state.y\r\n            }\r\n        } else {\r\n            state.y = prevState.y + prevState.virtualHeight;\r\n        }\r\n    },\r\n    getDomByStateId(stateId){\r\n        let doms = document.getElementsByClassName('state-wrap');\r\n        return Array.prototype.slice.call(doms).find(item => {\r\n            return item.getAttribute('stateid') === stateId;\r\n        })\r\n    },\r\n\r\n\r\n    testLayout(thread) {\r\n        var g = new dagre.graphlib.Graph({\r\n            //directed: true,\r\n            //compound: true,\r\n            multigraph: true,\r\n           \r\n        });\r\n        g.setGraph({\r\n            rankdir: 'LR',\r\n            align:'UL',\r\n            edgesep:0\r\n        });\r\n        g.setDefaultEdgeLabel(function() {\r\n            return {};\r\n        });\r\n\r\n        thread.stateAry.forEach(state => {\r\n            //需要考虑嵌套\r\n            g.setNode(state.stateId, {\r\n                label: state.name,\r\n                // width: state.width || 76,\r\n                // height: state.height || 40\r\n                width: parseInt(state.width.replace(\"px\",\"\"),10),\r\n                height: parseInt(state.height.replace(\"px\",\"\"),10)\r\n            });\r\n\r\n            state.outputAry.forEach(line => {\r\n                let lineObj = thread.lineAry.find(item => {\r\n                    return item.lineId === line.lineId;\r\n                })\r\n                let endState = thread.stateAry.find(item => {\r\n                    return item.stateId === lineObj.endState.stateId;\r\n                })\r\n                // g.setEdge(state.stateId, endState.stateId, line.lineId, lineObj.desc); //这种设置方式会报错 可能是dagre对graphlib的封装接口未同步\r\n                g.setEdge(state.stateId, endState.stateId, {\r\n                    label: line.lineId\r\n                });\r\n            })\r\n        })\r\n\r\n        dagre.layout(g);\r\n        g.nodes().forEach(function(nodeId) {\r\n            let node = g.node(nodeId);\r\n            let state = thread.stateAry.find(item => {\r\n                return item.stateId === nodeId;\r\n            });\r\n            if (state){\r\n                state.x = node.x;\r\n                state.y = node.y;\r\n            }\r\n            console.log(\"Node \" + nodeId + \": \" + JSON.stringify(g.node(nodeId)));\r\n        });\r\n        g.edges().forEach(function(line) {\r\n            console.log(\"Edge \" + line.v + \" -> \" + line.w + \": \" + JSON.stringify(g.edge(line)));\r\n            let lineObj = thread.lineAry.find(item => {\r\n                return item.lineId === g.edge(line).label;\r\n            });\r\n            QBlock.Line.redrawLine(lineObj, 0);\r\n        });\r\n    }\r\n}\r\nexport default Util;"]}