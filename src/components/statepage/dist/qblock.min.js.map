{"version":3,"sources":["qblock.js"],"names":["_util","_interopRequireDefault","require","_graphCfg","LINE_H","lineCfg","line_h","LINE_RADIUS","line_radius","QBlock","store","window","Thread","State","threadPos","document","getElementsByClassName","threadIndex","getBoundingClientRect","Util","getDomByStateId","state","stateId","x","statePos","left","y","top","getXY2Canvas","xy","parent","getState","parentXY","this","getStateHeight","translatePX2Num","height","getStateHeightByStateId","getStateWidth","width","getStartPoint","line","startState","threadTitleHeight","getEndPoint","endState","redrawLine","drawLine","startPoint","endPoint","Line","path","Math","abs","drawStraightConnectLine","isDynamicRadiusFlag","drawLine3ByPoint","radius","console"],"mappings":"2FAAA,IAAAA,MAAAC,uBAAAC,QAAA,cACAC,UAAAD,QAAA,yFACA,IAAME,OAASC,UAAAA,QAAQC,OACjBC,YAAcF,UAAAA,QAAQG,YACxBC,OAAS,CACTC,MAAOC,OAAOD,MACdE,OAAQ,GALZC,MAAA,CAEMN,8BAFN,SAE4BC,EAAAA,GAClB,IAAGM,EAAAC,SAAAC,uBAAA,UAAAC,GAAAC,wBACKR,EADLS,MAAAA,QAAAC,gBAAAC,EAAAC,SAAAJ,wBAAA,MAAA,CAKFK,EAAAC,EAAAC,KAAAX,EAAAW,KACHC,EAAAF,EAAAG,IAAAb,EAAAa,MAiBAC,aA1BR,SA0BqBP,EAAOJ,GAVhB,IAAOY,EAAA,CACAL,EAAQH,EAARE,EACAC,EAAQH,EAARK,GAVR,GAAAL,EAAAS,OAAA,CAwBK,IAAIA,EAASpB,MAAMqB,SAASd,EAAaI,EAAMC,SAAS,GAXhEU,EAAAC,KAAAL,aAAAE,EAAAb,GAaQY,EAAGN,GAAKS,EAAST,EACjBM,EAAGH,GAAKM,EAASN,EAErB,OAAOG,GAVPK,eA3BZ,SA2BqBb,GACFA,OADEF,MAAAA,QAAAgB,gBAAAd,EAAAe,SAATC,wBA3BZ,SA2BYpB,EAAAK,GAgBA,IAAID,EAAQX,MAAMqB,SAASd,EAAaK,GAAS,GAZ9CD,OAAMS,MAAAA,QAAOK,gBAAAd,EAAAe,SACiDE,cAhC7E,SAgC6EjB,GAA7D,OAAAF,MAAAA,QAAAgB,gBAAAd,EAAAkB,SAGAV,KAAE,CACLW,cADK,SACLC,EAAAxB,GAQD,IAAOE,EAAAA,MAAKgB,SAAAA,EAAsBC,EAAlCM,WAAApB,SAAA,GApCDO,EAAApB,OAAAI,MAAAe,aAAAc,EAAAzB,GAsCHqB,MAtCG,CAuCQnB,EAAAA,EAAAA,EAAAA,MAAAA,QAAKgB,gBAAgBd,EAA5BkB,OACHb,EAAAG,EAAAH,EAAAP,MAAAA,QAAAgB,gBAAAO,EAAAN,QAAA,EAAA/B,UAAAA,QAAAsC,oBAIGC,YAjBM,SAiBNH,EAAAxB,GAiBA,IAAI4B,EAAWnC,MAAMqB,SAASd,EAAawB,EAAKI,SAASvB,SAAS,GAC9DO,EAAKpB,OAAOI,MAAMe,aAAaiB,EAAU5B,GAC7C,MAAO,CACHM,EAAGM,EAAGN,EACNG,EAAGG,EAAGH,EAAIP,MAAAA,QAAKgB,gBAAgBU,EAAST,QAAU,EAAI/B,UAAAA,QAAQsC,oBAbSG,WAzBrE,SAyBqEL,EAAAxB,GAA3EgB,KAAAc,SAAAN,EAAAA,EAAAC,WAAAD,EAAAI,SAAA5B,IAEA8B,SA3BM,SA2BCN,EAAAC,EAAAG,EAAA5B,GACAY,IAAAmB,EAAO7B,EACPU,EAAOV,OAAAA,KAAKgB,cAAgBO,EAAAA,GAEnCO,EAAAxC,OAAAyC,KAAAN,YAAAH,EAAAxB,GAGI4B,IAAJM,EAAIN,EAAmEO,KAAAC,IAAAL,EAAAtB,EAAAuB,EAAAvB,GAAA,EAAAnB,YACjE,GAAGE,EAAOI,IAAMe,EAAaiB,GAAAA,EAAU5B,EAAAA,EAA7CM,EACO4B,EAAAlB,KAAAqB,wBAAAN,EAAAC,EAAA1C,kBAAA,GAAAyC,EAAAzB,EAAA0B,EAAA1B,EAAAnB,OAAAG,YAEA4C,EAAOhC,KAAAA,yBAEduB,EAzBFM,EAAAH,EA4BgBJ,OA5BhB,CAgCY,IAAGhC,EAAOyC,YACTzC,IAGP8C,EAAmBH,KACnBA,IAAKC,EAAIL,EAAAC,EAAeA,GAAxB,GAiBAE,EAAOlB,KAAKuB,iBAAiBR,EAAYC,EAAUQ,GAfvD,OACQC,QAAQJ,IAAAA,OAAAA,GACLN,cASHS","file":"qblock.min.js","sourcesContent":["import Util from './util.js'\r\nimport { lineCfg } from \"./graphCfg.js\";\r\nconst LINE_H = lineCfg.line_h;\r\nconst LINE_RADIUS = lineCfg.line_radius;\r\nvar QBlock = {\r\n    store: window.store,\r\n    Thread: {\r\n\r\n    },\r\n    State: {\r\n        /**\r\n         * 获取状态相对于线程框的坐标信息  此方法依赖状态组件的dom，不推荐使用\r\n         * @param {*} state\r\n         */\r\n        getXY2CanvasWithStateRendered(state, threadIndex) {\r\n            let threadPos = document.getElementsByClassName(\"thread\")[threadIndex].getBoundingClientRect();\r\n            let statePos = Util.getDomByStateId(state.stateId).getBoundingClientRect();\r\n            return {\r\n                x: statePos.left - threadPos.left,\r\n                y: statePos.top - threadPos.top\r\n            }\r\n        },\r\n        /**\r\n         * 根据状态及其父状态信息计算出相对于线程框的绝对位置  不依赖dom\r\n         * @param {*} state \r\n         * @param {*} threadIndex \r\n         */\r\n        getXY2Canvas(state, threadIndex){\r\n            let xy = {\r\n                x: state.x,\r\n                y: state.y\r\n            };\r\n            if(state.parent){\r\n                let parent = store.getState(threadIndex, state.stateId, false/**isThreadId: false */);\r\n                let parentXY = this.getXY2Canvas(parent, threadIndex);\r\n                xy.x += parentXY.x;\r\n                xy.y += parentXY.y;\r\n            }\r\n            return xy;\r\n        },\r\n        getStateHeight(state) {\r\n            return Util.translatePX2Num(state.height);\r\n        },\r\n        getStateHeightByStateId(threadIndex, stateId) {\r\n            let state = store.getState(threadIndex, stateId, false);\r\n            return Util.translatePX2Num(state.height);\r\n        },\r\n        getStateWidth(state) {\r\n            return Util.translatePX2Num(state.width);\r\n        }\r\n    },\r\n    Line: {\r\n        getStartPoint(line, threadIndex) {\r\n            /* if (\r\n                !line.startPoint ||\r\n                line.startPoint.x === null ||\r\n                typeof line.startPoint.x === \"undefined\" ||\r\n                isNaN(line.startPoint.x)\r\n            ) {\r\n                \r\n            } */\r\n            let startState = store.getState(threadIndex, line.startState.stateId, false/**isThreadId: false */);\r\n            let xy = QBlock.State.getXY2Canvas(startState, threadIndex);\r\n            return {\r\n                x: xy.x + Util.translatePX2Num(startState.width),\r\n                y: xy.y + Util.translatePX2Num(startState.height) / 2 + lineCfg.threadTitleHeight,\r\n            };\r\n            // return line.startPoint;\r\n        },\r\n        getEndPoint(line, threadIndex) {\r\n            let endState = store.getState(threadIndex, line.endState.stateId, false/**isThreadId: false */);\r\n            let xy = QBlock.State.getXY2Canvas(endState, threadIndex);\r\n            return {\r\n                x: xy.x,\r\n                y: xy.y + Util.translatePX2Num(endState.height) / 2 + lineCfg.threadTitleHeight,\r\n            };\r\n            // return line.endPoint;\r\n        },\r\n        redrawLine(line, threadIndex) {\r\n            this.drawLine(line, line.startState, line.endState, threadIndex);\r\n        },\r\n        drawLine(line, startState, endState, threadIndex) {\r\n            let startPoint, endPoint, stateHeight, linepath;\r\n            startPoint = QBlock.Line.getStartPoint(line, threadIndex);\r\n            endPoint = QBlock.Line.getEndPoint(line, threadIndex);\r\n\r\n\r\n            let isDynamicRadiusFlag =\r\n                Math.abs(startPoint.y - endPoint.y) < 2 * LINE_RADIUS;\r\n            let path;\r\n            if (endPoint.y === startPoint.y && endPoint.x > startPoint.x) {\r\n                path = this.drawStraightConnectLine(startPoint, endPoint, LINE_RADIUS);\r\n            } else if (startPoint.x > endPoint.x - LINE_H - LINE_RADIUS) {\r\n                path = this.drawLine5ByStateAndPoint(\r\n                    startState,\r\n                    startPoint,\r\n                    endState,\r\n                    endPoint\r\n                );\r\n            } else {\r\n                //若两个状态块之间的y轴距离小于2个预设拐角半径，则需要动态计算连线拐角的半径，并绘制连线\r\n                var radius = LINE_RADIUS;\r\n                if (isDynamicRadiusFlag) {\r\n                    radius = Math.abs(startPoint.y - endPoint.y) / 2;\r\n                }\r\n                path = this.drawLine3ByPoint(startPoint, endPoint, radius);\r\n            }\r\n            console.log('>>> ' + path);\r\n            return path;\r\n        },\r\n    }\r\n}\r\nexport default QBlock;"]}